{"/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/test.js":"/* istanbul instrument in package npmtest_ember_cli_mirage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/lib.npmtest_ember_cli_mirage.js":"/* istanbul instrument in package npmtest_ember_cli_mirage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ember_cli_mirage = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ember_cli_mirage = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ember-cli-mirage && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ember_cli_mirage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ember_cli_mirage\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ember_cli_mirage.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ember_cli_mirage.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ember_cli_mirage.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ember_cli_mirage.__dirname + '/lib.npmtest_ember_cli_mirage.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/index.js":"/* eslint-env node */\n'use strict';\nvar path = require('path');\nvar mergeTrees = require('broccoli-merge-trees');\nvar Funnel = require('broccoli-funnel');\n\nmodule.exports = {\n  name: 'ember-cli-mirage',\n\n  options: {\n    nodeAssets: {\n      'route-recognizer': npmAsset({\n        path: 'dist/route-recognizer.js',\n        sourceMap: 'dist/route-recognizer.js.map'\n      }),\n      'fake-xml-http-request': npmAsset('fake_xml_http_request.js'),\n      'pretender': npmAsset('pretender.js'),\n      'faker': npmAsset('build/build/faker.js')\n    }\n  },\n\n  included: function included() {\n    var app;\n\n    // If the addon has the _findHost() method (in ember-cli >= 2.7.0), we'll just\n    // use that.\n    if (typeof this._findHost === 'function') {\n      app = this._findHost();\n    } else {\n      // Otherwise, we'll use this implementation borrowed from the _findHost()\n      // method in ember-cli.\n      var current = this;\n      do {\n        app = current.app || app;\n      } while (current.parent.parent && (current = current.parent));\n    }\n\n    this.app = app;\n    this.addonConfig = this.app.project.config(app.env)['ember-cli-mirage'] || {};\n    this.addonBuildConfig = this.app.options['ember-cli-mirage'] || {};\n\n    // Call super after initializing config so we can use _shouldIncludeFiles for the node assets\n    this._super.included.apply(this, arguments);\n\n    if (this.addonBuildConfig.directory) {\n      this.mirageDirectory = this.addonBuildConfig.directory;\n    } else if (this.addonConfig.directory) {\n      this.mirageDirectory = this.addonConfig.directory;\n    } else if (app.project.pkg['ember-addon'] && !app.project.pkg['ember-addon'].paths) {\n      this.mirageDirectory = path.resolve(app.project.root, path.join('tests', 'dummy', 'mirage'));\n    } else {\n      this.mirageDirectory = path.join(this.app.project.root, '/mirage');\n    }\n\n    if (this._shouldIncludeFiles()) {\n      app.import('vendor/ember-cli-mirage/pretender-shim.js', {\n        type: 'vendor',\n        exports: { 'pretender': ['default'] }\n      });\n    }\n  },\n\n  blueprintsPath: function() {\n    return path.join(__dirname, 'blueprints');\n  },\n\n  treeFor: function(name) {\n    if (!this._shouldIncludeFiles()) {\n      return;\n    }\n\n    return this._super.treeFor.apply(this, arguments);\n  },\n\n  _lintMirageTree: function(mirageTree) {\n    var lintedMirageTrees;\n    // _eachProjectAddonInvoke was added in ember-cli@2.5.0\n    // this conditional can be removed when we no longer support\n    // versions older than 2.5.0\n    if (this._eachProjectAddonInvoke) {\n      lintedMirageTrees = this._eachProjectAddonInvoke('lintTree', ['mirage', mirageTree]);\n    } else {\n      lintedMirageTrees = this.project.addons.map(function(addon) {\n        if (addon.lintTree) {\n          return addon.lintTree('mirage', mirageTree);\n        }\n      }).filter(Boolean);\n    }\n\n    var lintedMirage = mergeTrees(lintedMirageTrees, {\n      overwrite: true,\n      annotation: 'TreeMerger (mirage-lint)'\n    });\n\n    return new Funnel(lintedMirage, {\n      destDir: 'tests/mirage/'\n    });\n  },\n\n  treeForApp: function(appTree) {\n    var trees = [ appTree ];\n    var mirageFilesTree = new Funnel(this.mirageDirectory, {\n      destDir: 'mirage'\n    });\n    trees.push(mirageFilesTree);\n\n    if (this.hintingEnabled()) {\n      trees.push(this._lintMirageTree(mirageFilesTree));\n    }\n\n    return mergeTrees(trees);\n  },\n\n  _shouldIncludeFiles: function() {\n    if (process.env.EMBER_CLI_FASTBOOT) {\n      return false;\n    }\n\n    var environment = this.app.env;\n    var enabledInProd = environment === 'production' && this.addonConfig.enabled;\n    var explicitExcludeFiles = this.addonConfig.excludeFilesFromBuild;\n    if (enabledInProd && explicitExcludeFiles) {\n      throw new Error('Mirage was explicitly enabled in production, but its files were excluded '\n                      + 'from the build. Please, use only ENV[\\'ember-cli-mirage\\'].enabled in '\n                      + 'production environment.');\n    }\n    return enabledInProd || (environment && environment !== 'production' && explicitExcludeFiles !== true);\n  }\n};\n\nfunction npmAsset(filePath) {\n  return function() {\n    return {\n      enabled: this._shouldIncludeFiles(),\n      import: [filePath]\n    };\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/.eslintrc.js":"module.exports = {\n  root: true,\n  parserOptions: {\n    ecmaVersion: 6,\n    sourceType: 'module'\n  },\n  extends: [\n    'eslint:recommended',\n    'plugin:ember-suave/recommended'\n  ],\n  env: {\n    'browser': true\n  },\n  rules: {\n    'camelcase': 0,\n    'ember-suave/no-direct-property-access': 0,\n    'ember-suave/prefer-destructuring': 0,\n    'object-curly-spacing': 0,\n    'quotes': 0,\n    'array-bracket-spacing': 0,\n    'no-var': 0,\n    'object-shorthand': 0,\n    'arrow-parens': 0,\n    'no-unused-vars': ['error', { 'args': 'none' }]\n  },\n  globals: {\n    faker: true,\n    server: true,\n    $: true\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/assert.js":"/* eslint no-console: 0 */\nlet errorProps = [\n  'description',\n  'fileName',\n  'lineNumber',\n  'message',\n  'name',\n  'number',\n  'stack'\n];\n\nexport default function assert(bool, text) {\n  if (typeof bool === 'string' && !text) {\n    throw new MirageError(bool);\n  }\n\n  if (!bool) {\n    throw new MirageError(text.replace(/^ +/gm, '') || 'Assertion failed');\n  }\n}\n\n/**\n  @public\n  Copied from ember-metal/error\n*/\nexport function MirageError() {\n  let tmp = Error.apply(this, arguments);\n\n  for (let idx = 0; idx < errorProps.length; idx++) {\n    let prop = errorProps[idx];\n\n    if (['description', 'message', 'stack'].indexOf(prop) > -1) {\n      this[prop] = `Mirage: ${tmp[prop]}`;\n    } else {\n      this[prop] = tmp[prop];\n    }\n  }\n\n  console.error(this.message);\n  console.error(this);\n}\n\nMirageError.prototype = Object.create(Error.prototype);\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/association.js":"let association = function(...traitsAndOverrides) {\n  let __isAssociation__ = true;\n  return {\n    __isAssociation__,\n    traitsAndOverrides\n  };\n};\n\nexport default association;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/db-collection.js":"import _assign from 'lodash/assign';\nimport _map from 'lodash/map';\nimport _isEqual from 'lodash/isEqual';\nimport _sortBy from 'lodash/sortBy';\n\nfunction duplicate(data) {\n  if (Array.isArray(data)) {\n    return data.map(duplicate);\n  } else {\n    return _assign({}, data);\n  }\n}\n\nfunction isNumber(n) {\n  return (+n).toString() === n.toString();\n}\n\n/**\n *  A collection of db records i.e. a database table.\n *  @class DbCollection\n *  @constructor\n *  @public\n */\nclass DbCollection {\n\n  constructor(name, initialData) {\n    this.name = name;\n    this._records = [];\n    this.identityManager = new IdentityManager();\n\n    if (initialData) {\n      this.insert(initialData);\n    }\n  }\n\n  /**\n   * Returns a copy of the data, to prevent inadvertent data manipulation.\n   * @method all\n   * @public\n   */\n  all() {\n    return duplicate(this._records);\n  }\n\n  /**\n   * Inserts `data` into the collection. `data` can be a single object\n   * or an array of objects. Returns the inserted record.\n   * @method insert\n   * @param data\n   * @public\n   */\n  insert(data) {\n    if (!Array.isArray(data)) {\n      return this._insertRecord(data);\n    } else {\n      // Need to sort in order to ensure IDs inserted in the correct order\n      let sorted = _sortBy(data, 'id');\n      return _map(sorted, (x) => this._insertRecord(x));\n    }\n  }\n\n  /**\n   * Returns a single record from the `collection` if `ids` is a single\n   * id, or an array of records if `ids` is an array of ids. Note\n   * each id can be an int or a string, but integer ids as strings\n   * (e.g. the string “1”) will be treated as integers.\n   * @method find\n   * @param ids\n   * @public\n   */\n  find(ids) {\n    if (Array.isArray(ids)) {\n      let records = this._findRecords(ids)\n        .filter(Boolean)\n        .map(duplicate); // Return a copy\n\n      return records;\n    } else {\n      let record = this._findRecord(ids);\n      if (!record) {\n        return null;\n      }\n\n      // Return a copy\n      return duplicate(record);\n    }\n  }\n\n  /**\n   * Returns the first model from `collection` that matches the\n   * key-value pairs in the `query` object. Note that a string\n   * comparison is used. `query` is a POJO.\n   * @method find\n   * @param query\n   * @public\n   */\n  findBy(query) {\n    let record = this._findRecordBy(query);\n    if (!record) {\n      return null;\n    }\n\n    // Return a copy\n    return duplicate(record);\n  }\n\n  /**\n   * Returns an array of models from `collection` that match the\n   * key-value pairs in the `query` object. Note that a string\n   * comparison is used. `query` is a POJO.\n   * @method where\n   * @param query\n   * @public\n   */\n  where(query) {\n    return this._findRecordsWhere(query).map(duplicate);\n  }\n\n  /**\n   * Finds the first record matching the provided query in\n   * `collection`, or creates a new record using a merge of the\n   * `query` and optional `attributesForCreate`.\n   * @method firstOrCreate\n   * @param query\n   * @param attributesForCreate\n   * @public\n   */\n  firstOrCreate(query, attributesForCreate = {}) {\n    let queryResult = this.where(query);\n    let [record] = queryResult;\n\n    if (record) {\n      return record;\n    } else {\n      let mergedAttributes = _assign(attributesForCreate, query);\n      let createdRecord = this.insert(mergedAttributes);\n\n      return createdRecord;\n    }\n  }\n\n  /**\n   * Updates one or more records in collection.\n   * If attrs is the only arg present, updates all records\n   * in the collection according to the key-value pairs in attrs.\n   * If target is present, restricts updates to those that\n   * match target. If target is a number or string, finds a\n   * single record whose id is target to update. If target is\n   * a POJO, queries collection for records that match the\n   * key-value pairs in target, and updates their attrs.\n   * Returns the updated record or records.\n   * @method update\n   * @param target\n   * @param attrs\n   * @public\n   */\n  update(target, attrs) {\n    let records;\n\n    if (typeof attrs === 'undefined') {\n      attrs = target;\n      let changedRecords = [];\n\n      this._records.forEach((record) => {\n        let oldRecord = _assign({}, record);\n\n        this._updateRecord(record, attrs);\n\n        if (!_isEqual(oldRecord, record)) {\n          changedRecords.push(record);\n        }\n      });\n\n      return changedRecords;\n\n    } else if (typeof target === 'number' || typeof target === 'string') {\n      let id = target;\n      let record = this._findRecord(id);\n\n      this._updateRecord(record, attrs);\n\n      return record;\n\n    } else if (Array.isArray(target)) {\n      let ids = target;\n      records = this._findRecords(ids);\n\n      records.forEach((record) => {\n        this._updateRecord(record, attrs);\n      });\n\n      return records;\n\n    } else if (typeof target === 'object') {\n      let query = target;\n      records = this._findRecordsWhere(query);\n\n      records.forEach((record) => {\n        this._updateRecord(record, attrs);\n      });\n\n      return records;\n    }\n  }\n\n  /**\n   * Removes one or more records in `collection`.\n   * If `target` is undefined, removes all records.\n   * If `target` is a number or string, removes a\n   * single record using `target` as id. If `target` is\n   * a POJO, queries `collection` for records that\n   * match the key-value pairs in `target`, and\n   * removes them from the collection.\n   * @method remove\n   * @param target\n   * @public\n   */\n  remove(target) {\n    let records;\n\n    if (typeof target === 'undefined') {\n      this._records = [];\n      this.identityManager.reset();\n\n    } else if (typeof target === 'number' || typeof target === 'string') {\n      let record = this._findRecord(target);\n      let index = this._records.indexOf(record);\n      this._records.splice(index, 1);\n\n    } else if (Array.isArray(target)) {\n      records = this._findRecords(target);\n      records.forEach((record) =>  {\n        let index = this._records.indexOf(record);\n        this._records.splice(index, 1);\n      });\n\n    } else if (typeof target === 'object') {\n      records = this._findRecordsWhere(target);\n      records.forEach((record) =>  {\n        let index = this._records.indexOf(record);\n        this._records.splice(index, 1);\n      });\n    }\n  }\n\n  /*\n    Private methods.\n\n    These return the actual db objects, whereas the public\n    API query methods return copies.\n  */\n\n  /**\n   * @method _findRecord\n   * @param id\n   * @private\n   */\n  _findRecord(id) {\n    id = id.toString();\n\n    let [record] = this._records.filter((obj) => obj.id === id);\n\n    return record;\n  }\n\n  /**\n   * @method _findRecordBy\n   * @param query\n   * @private\n   */\n  _findRecordBy(query) {\n    return this._findRecordsWhere(query)[0];\n  }\n\n  /**\n   * @method _findRecords\n   * @param ids\n   * @private\n   */\n  _findRecords(ids) {\n    return ids.map(this._findRecord, this);\n  }\n\n  /**\n   * @method _findRecordsWhere\n   * @param query\n   * @private\n   */\n  _findRecordsWhere(query) {\n    let records = this._records;\n\n    function defaultQueryFunction(record) {\n      let keys = Object.keys(query);\n\n      return keys.every(function(key) {\n        return String(record[key]) === String(query[key]);\n      });\n    }\n\n    let queryFunction = typeof query === 'object' ? defaultQueryFunction : query;\n\n    return records.filter(queryFunction);\n  }\n\n  /**\n   * @method _insertRecord\n   * @param data\n   * @private\n   */\n  _insertRecord(data) {\n    let attrs = duplicate(data);\n\n    if (attrs && (attrs.id === undefined || attrs.id === null)) {\n      attrs.id = this.identityManager.fetch();\n    } else {\n      attrs.id = attrs.id.toString();\n\n      this.identityManager.set(attrs.id);\n    }\n\n    this._records.push(attrs);\n\n    return duplicate(attrs);\n  }\n\n  /**\n   * @method _updateRecord\n   * @param record\n   * @param attrs\n   * @private\n   */\n  _updateRecord(record, attrs) {\n    let targetId = (attrs && attrs.hasOwnProperty('id')) ? attrs.id.toString() : null;\n    let currentId = record.id;\n\n    if (targetId && currentId !== targetId) {\n      throw new Error('Updating the ID of a record is not permitted');\n    }\n\n    for (let attr in attrs) {\n      if (attr === 'id') {\n        continue;\n      }\n\n      record[attr] = attrs[attr];\n    }\n  }\n}\n\nclass IdentityManager {\n  constructor() {\n    this._nextId = 1;\n    this._ids = {};\n  }\n\n  get() {\n    return this._nextId;\n  }\n\n  set(n) {\n    if (this._ids[n]) {\n      throw new Error(`Attempting to use the ID ${n}, but it's already been used`);\n    }\n\n    if (isNumber(n) && +n >= this._nextId) {\n      this._nextId = +n + 1;\n    }\n\n    this._ids[n] = true;\n  }\n\n  inc() {\n    let nextValue = this.get() + 1;\n\n    this._nextId = nextValue;\n\n    return nextValue;\n  }\n\n  fetch() {\n    let id = this.get();\n\n    this._ids[id] = true;\n\n    this.inc();\n\n    return id.toString();\n  }\n\n  reset() {\n    this._nextId = 1;\n    this._ids = {};\n  }\n}\n\nexport default DbCollection;\n\nexport { IdentityManager };\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/db.js":"import DbCollection from './db-collection';\n\n/**\n * The db, an identity map.\n * @class Db\n * @constructor\n * @public\n */\nclass Db {\n\n  constructor(initialData) {\n    this._collections = [];\n\n    if (initialData) {\n      this.loadData(initialData);\n    }\n  }\n\n  /**\n   * @method loadData\n   * @param data\n   * @public\n   */\n  loadData(data) {\n    for (let key in data) {\n      this.createCollection(key, data[key]);\n    }\n  }\n\n  /**\n   * @method dump\n   * @public\n   */\n  dump() {\n    return this._collections.reduce((data, collection) => {\n      data[collection.name] = collection.all();\n\n      return data;\n    }, {});\n  }\n\n  /**\n   * @method createCollection\n   * @param name\n   * @param initialData\n   * @public\n   */\n  createCollection(name, initialData) {\n    if (!this[name]) {\n      let newCollection = new DbCollection(name, initialData);\n\n      Object.defineProperty(this, name, {\n        get() {\n          let recordsCopy = newCollection.all();\n\n          ['insert', 'find', 'findBy', 'where', 'update', 'remove', 'firstOrCreate']\n            .forEach(function(method) {\n              recordsCopy[method] = function() {\n                return newCollection[method](...arguments);\n              };\n            });\n\n          return recordsCopy;\n        }\n      });\n\n      this._collections.push(newCollection);\n\n    } else if (initialData) {\n      this[name].insert(initialData);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method createCollections\n   * @param ...collections\n   * @public\n   */\n  createCollections(...collections) {\n    collections.forEach((c) => this.createCollection(c));\n  }\n\n  /**\n   * @method emptyData\n   * @public\n   */\n  emptyData() {\n    this._collections.forEach((c) => c.remove());\n  }\n}\n\nexport default Db;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/factory.js":"import _assign from 'lodash/assign';\nimport _isFunction from 'lodash/isFunction';\nimport _mapValues from 'lodash/mapValues';\nimport referenceSort from './utils/reference-sort';\nimport _isPlainObject from 'lodash/isPlainObject';\n\nlet Factory = function() {\n  this.build = function(sequence) {\n    let object = {};\n    let topLevelAttrs = _assign({}, this.attrs);\n    delete topLevelAttrs.afterCreate;\n    Object.keys(topLevelAttrs).forEach((attr) => {\n      if (Factory.isTrait.call(this, attr)) {\n        delete topLevelAttrs[attr];\n      }\n    });\n    let keys = sortAttrs(topLevelAttrs, sequence);\n\n    keys.forEach(function(key) {\n      let buildAttrs, buildSingleValue;\n\n      buildAttrs = function(attrs) {\n        return _mapValues(attrs, buildSingleValue);\n      };\n\n      buildSingleValue = (value) => {\n        if (Array.isArray(value)) {\n          return value.map(buildSingleValue);\n        } else if (_isPlainObject(value)) {\n          return buildAttrs(value);\n        } else if (_isFunction(value)) {\n          return value.call(topLevelAttrs, sequence);\n        } else {\n          return value;\n        }\n      };\n\n      let value = topLevelAttrs[key];\n      if (_isFunction(value)) {\n        object[key] = value.call(object, sequence);\n      } else {\n        object[key] = buildSingleValue(value);\n      }\n\n    });\n\n    return object;\n  };\n};\n\nFactory.extend = function(attrs) {\n  // Merge the new attributes with existing ones. If conflict, new ones win.\n  let newAttrs = _assign({}, this.attrs, attrs);\n\n  let Subclass = function() {\n    this.attrs = newAttrs;\n    Factory.call(this);\n  };\n\n  // Copy extend\n  Subclass.extend = Factory.extend;\n  Subclass.extractAfterCreateCallbacks = Factory.extractAfterCreateCallbacks;\n  Subclass.isTrait = Factory.isTrait;\n\n  // Store a reference on the class for future subclasses\n  Subclass.attrs = newAttrs;\n\n  return Subclass;\n};\n\nFactory.extractAfterCreateCallbacks = function({ traits } = {}) {\n  let afterCreateCallbacks = [];\n  let attrs = this.attrs || {};\n  let traitCandidates;\n\n  if (attrs.afterCreate) {\n    afterCreateCallbacks.push(attrs.afterCreate);\n  }\n\n  if (Array.isArray(traits)) {\n    traitCandidates = traits;\n  } else {\n    traitCandidates = Object.keys(attrs);\n  }\n\n  traitCandidates.filter((attr) => {\n    return this.isTrait(attr) && attrs[attr].extension.afterCreate;\n  }).forEach((attr) => {\n    afterCreateCallbacks.push(attrs[attr].extension.afterCreate);\n  });\n\n  return afterCreateCallbacks;\n};\n\nFactory.isTrait = function(attrName) {\n  let { attrs } = this;\n  return _isPlainObject(attrs[attrName]) && attrs[attrName].__isTrait__ === true;\n};\n\nfunction sortAttrs(attrs, sequence) {\n  let Temp = function() {};\n  let obj = new Temp();\n  let refs = [];\n  let property;\n\n  Object.keys(attrs).forEach(function(key) {\n    let value;\n    Object.defineProperty(obj.constructor.prototype, key, {\n      get() {\n        refs.push([property, key]);\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n      },\n      enumerable: false,\n      configurable: true\n    });\n  });\n\n  Object.keys(attrs).forEach(function(key) {\n    let value = attrs[key];\n    if (typeof value !== 'function') {\n      obj[key] = value;\n    }\n  });\n\n  Object.keys(attrs).forEach(function(key) {\n    let value = attrs[key];\n    property = key;\n\n    if (typeof value === 'function') {\n      obj[key] = value.call(obj, sequence);\n    }\n\n    refs.push([key]);\n  });\n\n  return referenceSort(refs);\n}\n\nexport default Factory;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/faker.js":"let list = {\n  random() {\n    let items = arguments.length > 0 ? arguments : [];\n\n    return function() {\n      return faker.random.arrayElement(items);\n    };\n  },\n\n  cycle() {\n    let items = arguments.length > 0 ? arguments : [];\n\n    return function(i) {\n      return items[i % items.length];\n    };\n  }\n};\n\nfaker.list = list;\n\nfaker.random.number.range = function(min, max) {\n  return function(/* i */) {\n    return Math.random() * (max - min) + min;\n  };\n};\n\nexport default faker;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/response.js":"export default class Response {\n\n  constructor(code, headers = {}, data = {}) {\n    this.code = code;\n    this.headers = headers;\n    this.data = data;\n  }\n\n  toRackResponse() {\n    let { headers } = this;\n    if (!headers.hasOwnProperty('Content-Type')) {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    return [this.code, this.headers, this.data];\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handler.js":"import Ember from 'ember';\nimport { MirageError } from 'ember-cli-mirage/assert';\nimport Response from './response';\nimport FunctionHandler from './route-handlers/function';\nimport ObjectHandler from './route-handlers/object';\nimport GetShorthandHandler from './route-handlers/shorthands/get';\nimport PostShorthandHandler from './route-handlers/shorthands/post';\nimport PutShorthandHandler from './route-handlers/shorthands/put';\nimport DeleteShorthandHandler from './route-handlers/shorthands/delete';\nimport HeadShorthandHandler from './route-handlers/shorthands/head';\n\nconst { RSVP: { Promise }, isBlank, typeOf } = Ember;\n\nfunction isNotBlankResponse(response) {\n  return response\n    && !(typeOf(response) === 'object' && Object.keys(response).length === 0)\n    && (Array.isArray(response) || !isBlank(response));\n}\n\nconst DEFAULT_CODES = { get: 200, put: 204, post: 201, 'delete': 204 };\n\nfunction createHandler({ verb, schema, serializerOrRegistry, path, rawHandler, options }) {\n  let handler;\n  let args = [schema, serializerOrRegistry, rawHandler, path, options];\n  let type = typeOf(rawHandler);\n\n  if (type === 'function') {\n    handler = new FunctionHandler(...args);\n  } else if (type === 'object') {\n    handler = new ObjectHandler(...args);\n  } else if (verb === 'get') {\n    handler = new GetShorthandHandler(...args);\n  } else if (verb === 'post') {\n    handler = new PostShorthandHandler(...args);\n  } else if (verb === 'put' || verb === 'patch') {\n    handler = new PutShorthandHandler(...args);\n  } else if (verb === 'delete') {\n    handler = new DeleteShorthandHandler(...args);\n  } else if (verb === 'head') {\n    handler = new HeadShorthandHandler(...args);\n  }\n  return handler;\n}\n\nexport default class RouteHandler {\n\n  constructor({ schema, verb, rawHandler, customizedCode, options, path, serializerOrRegistry }) {\n    this.verb = verb;\n    this.customizedCode = customizedCode;\n    this.serializerOrRegistry = serializerOrRegistry;\n    this.handler = createHandler({ verb, schema, path, serializerOrRegistry, rawHandler, options });\n  }\n\n  handle(request) {\n    return new Promise(resolve => {\n      this._getMirageResponseForRequest(request).then(mirageResponse => {\n        this.serialize(mirageResponse, request).then(serializedMirageResponse => {\n          resolve(serializedMirageResponse.toRackResponse());\n        });\n      });\n    });\n  }\n\n  _getMirageResponseForRequest(request) {\n    let result;\n    try {\n      /*\n       We need to do this for the #serialize convenience method. Probably is\n       a better way.\n     */\n      if (this.handler instanceof FunctionHandler) {\n        this.handler.setRequest(request);\n      }\n\n      result = this.handler.handle(request);\n    } catch(e) {\n      if (e instanceof MirageError) {\n        throw e;\n      } else {\n        let message = (typeOf(e) === 'string') ? e : e.message;\n        throw new MirageError(`Your handler for the url ${request.url} threw an error: ${message}`);\n      }\n    }\n\n    return this._toMirageResponse(result);\n  }\n\n  _toMirageResponse(result) {\n    let mirageResponse;\n\n    return new Promise(resolve => {\n      Promise.resolve(result).then(response => {\n        if (response instanceof Response) {\n          mirageResponse = result;\n        } else {\n          let code = this._getCodeForResponse(response);\n          mirageResponse = new Response(code, {}, response);\n        }\n        resolve(mirageResponse);\n      });\n\n    });\n  }\n\n  _getCodeForResponse(response) {\n    let code;\n    if (this.customizedCode) {\n      code = this.customizedCode;\n    } else {\n      code = DEFAULT_CODES[this.verb];\n      if (code === 204 && isNotBlankResponse(response)) {\n        code = 200;\n      }\n    }\n    return code;\n  }\n\n  serialize(mirageResponsePromise, request) {\n    return new Promise(resolve => {\n      Promise.resolve(mirageResponsePromise).then(mirageResponse => {\n        mirageResponse.data = this.serializerOrRegistry.serialize(mirageResponse.data, request);\n        resolve(mirageResponse);\n      });\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/serializer-registry.js":"import Model from 'ember-cli-mirage/orm/model';\nimport Collection from 'ember-cli-mirage/orm/collection';\nimport Serializer from 'ember-cli-mirage/serializer';\nimport JsonApiSerializer from 'ember-cli-mirage/serializers/json-api-serializer';\nimport { pluralize, camelize } from './utils/inflector';\nimport assert from './assert';\n\nimport _assign from 'lodash/assign';\n\nexport default class SerializerRegistry {\n\n  constructor(schema, serializerMap = {}) {\n    this.schema = schema;\n    this._serializerMap = serializerMap;\n  }\n\n  normalize(payload, modelName) {\n    return this.serializerFor(modelName).normalize(payload);\n  }\n\n  serialize(response, request) {\n    this.request = request;\n\n    if (this._isModelOrCollection(response)) {\n      let serializer = this.serializerFor(response.modelName);\n\n      return serializer.serialize(response, request);\n    } else if (Array.isArray(response) && response.filter(this._isCollection).length) {\n      return response.reduce((json, collection) => {\n        let serializer = this.serializerFor(collection.modelName);\n\n        if (serializer.embed) {\n          json[pluralize(collection.modelName)] = serializer.serialize(collection, request);\n        } else {\n          json = _assign(json, serializer.serialize(collection, request));\n        }\n\n        return json;\n      }, {});\n\n    } else {\n      return response;\n    }\n  }\n\n  serializerFor(type, { explicit = false } = {}) {\n    let SerializerForResponse = this._serializerMap && (this._serializerMap[camelize(type)]);\n\n    if (explicit) {\n      assert(!!SerializerForResponse, `You passed in ${type} as an explicit serializer type but that serializer doesn't exist. Try running \\`ember g mirage-serializer ${type}\\`.`);\n    } else {\n      SerializerForResponse = SerializerForResponse || this._serializerMap.application || Serializer;\n\n      assert(\n        !SerializerForResponse\n        || (SerializerForResponse.prototype.embed)\n        || (SerializerForResponse.prototype.root)\n        || (new SerializerForResponse() instanceof JsonApiSerializer),\n        'You cannot have a serializer that sideloads (embed: false) and disables the root (root: false).'\n      );\n    }\n\n    return new SerializerForResponse(this, type, this.request);\n  }\n\n  _isModel(object) {\n    return object instanceof Model;\n  }\n\n  _isCollection(object) {\n    return object instanceof Collection;\n  }\n\n  _isModelOrCollection(object) {\n    return this._isModel(object) || this._isCollection(object);\n  }\n\n  registerSerializers(newSerializerMaps) {\n    let currentSerializerMap = this._serializerMap || {};\n    this._serializerMap = _assign(\n      currentSerializerMap,\n      newSerializerMaps\n    );\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/serializer.js":"import Model from './orm/model';\nimport Collection from './orm/collection';\nimport extend from './utils/extend';\nimport { singularize, pluralize, camelize } from './utils/inflector';\n\nimport _isFunction from 'lodash/isFunction';\nimport _isArray from 'lodash/isArray';\nimport _isEmpty from 'lodash/isEmpty';\nimport _includes from 'lodash/includes';\nimport _assign from 'lodash/assign';\nimport _get from 'lodash/get';\nimport _ from 'lodash';\n\nclass Serializer {\n\n  constructor(registry, type, request) {\n    this.registry = registry;\n    this.type = type;\n    this.request = request;\n  }\n\n  /**\n   * Override this method to implement your own custom\n   * serialize function. `primaryResource` is whatever was returned\n   * from your route handler, and request is the Pretender\n   * request object. Returns a plain JavaScript object or\n   * array, which Mirage uses as the response data to your\n   * Ember app’s XHR request. You can also override this method,\n   * call super, and manipulate the data before Mirage responds\n   * with it. This is a great place to add metadata, or for\n   * one-off operations that don’t fit neatly into any of\n   * Mirage’s other abstractions.\n   * @method serialize\n   * @param response\n   * @param request\n   * @public\n   */\n  serialize(primaryResource /* , request */) {\n    return this.buildPayload(primaryResource);\n  }\n\n  buildPayload(primaryResource, toInclude, didSerialize, json) {\n    if (!primaryResource && _isEmpty(toInclude)) {\n      return json;\n\n    } else if (primaryResource) {\n      let [resourceHash, newIncludes] = this.getHashForPrimaryResource(primaryResource);\n      let newDidSerialize = (this.isCollection(primaryResource) ? primaryResource.models : [primaryResource]);\n\n      return this.buildPayload(undefined, newIncludes, newDidSerialize, resourceHash);\n\n    } else {\n      let nextIncludedResource = toInclude.shift();\n      let [resourceHash, newIncludes] = this.getHashForIncludedResource(nextIncludedResource);\n\n      let newToInclude = newIncludes\n        .filter((resource) => {\n          return !_includes(didSerialize.map((m) => m.toString()), resource.toString());\n        })\n        .concat(toInclude);\n      let newDidSerialize = (this.isCollection(nextIncludedResource) ? nextIncludedResource.models : [nextIncludedResource])\n        .concat(didSerialize);\n      let newJson = this.mergePayloads(json, resourceHash);\n\n      return this.buildPayload(undefined, newToInclude, newDidSerialize, newJson);\n    }\n  }\n\n  getHashForPrimaryResource(resource) {\n    let [hash, addToIncludes] = this.getHashForResource(resource);\n    let hashWithRoot;\n\n    if (this.root) {\n      let serializer = this.serializerFor(resource.modelName);\n      let rootKey = serializer.keyForResource(resource);\n      hashWithRoot = { [rootKey]: hash };\n    } else {\n      hashWithRoot = hash;\n    }\n\n    return [hashWithRoot, addToIncludes];\n  }\n\n  getHashForIncludedResource(resource) {\n    let serializer = this.serializerFor(resource.modelName);\n    let [hash, addToIncludes] = serializer.getHashForResource(resource);\n\n    // Included resources always have a root, and are always pushed to an array.\n    let rootKey = serializer.keyForRelationship(resource.modelName);\n    let hashWithRoot = _isArray(hash) ? { [rootKey]: hash } : { [rootKey]: [hash] };\n\n    return [hashWithRoot, addToIncludes];\n  }\n\n  getHashForResource(resource, removeForeignKeys = false, didSerialize = {}, lookupSerializer = false) {\n    let hash;\n    let serializer = lookupSerializer ? this.serializerFor(resource.modelName) : this; // this is used for embedded responses\n\n    if (this.isModel(resource)) {\n      hash = serializer._hashForModel(resource, removeForeignKeys, didSerialize);\n    } else {\n      hash = resource.models.map((m) => serializer._hashForModel(m, removeForeignKeys, didSerialize));\n    }\n\n    if (this.embed) {\n      return [hash];\n\n    } else {\n      let addToIncludes = _(serializer.getKeysForIncluded())\n        .map((key) => {\n          if (this.isCollection(resource)) {\n            return resource.models.map((m) => m[key]);\n          } else {\n            return resource[key];\n          }\n        })\n        .flatten()\n        .compact()\n        .uniqBy(m => m.toString())\n        .value();\n\n      return [hash, addToIncludes];\n    }\n  }\n\n  /*\n    Merges new resource hash into json. If json already has root key,\n    pushes value of resourceHash onto that key.\n\n    For example,\n\n        json = {\n          post: { id: 1, title: 'Lorem Ipsum', comment_ids: [1, 3] },\n          comments: [\n            { id: 1, text: 'foo' }\n          ]\n        };\n\n        resourceHash = {\n          comments: [\n            { id: 2, text: 'bar' }\n          ]\n        };\n\n    would yield\n\n        {\n          post: { id: 1, title: 'Lorem Ipsum', comment_ids: [1, 3] },\n          comments: [\n            { id: 1, text: 'foo' },\n            { id: 2, text: 'bar' }\n          ]\n        };\n\n  */\n  mergePayloads(json, resourceHash) {\n    let newJson;\n    let [resourceHashKey] = Object.keys(resourceHash);\n\n    if (json[resourceHashKey]) {\n      newJson = json;\n      newJson[resourceHashKey] = json[resourceHashKey].concat(resourceHash[resourceHashKey]);\n    } else {\n      newJson = _assign(json, resourceHash);\n    }\n\n    return newJson;\n  }\n\n  keyForResource(resource) {\n    let { modelName } = resource;\n    return this.isModel(resource) ? this.keyForModel(modelName) : this.keyForCollection(modelName);\n  }\n\n  /**\n   * Used to define a custom key when serializing a\n   * primary model of modelName `modelName`.\n   * @method keyForModel\n   * @param modelName\n   * @public\n   */\n  keyForModel(modelName) {\n    return camelize(modelName);\n  }\n\n  /**\n   * Used to customize the key when serializing a primary\n   * collection. By default this pluralizes the return\n   * value of `keyForModel`.\n   * @method keyForCollection\n   * @param modelName\n   * @public\n   */\n  keyForCollection(modelName) {\n    return pluralize(this.keyForModel(modelName));\n  }\n\n  _hashForModel(model, removeForeignKeys, didSerialize = {}) {\n    let attrs = this._attrsForModel(model);\n\n    if (removeForeignKeys) {\n      model.fks.forEach((fk) => {\n        delete attrs[fk];\n      });\n    }\n\n    if (this.embed) {\n      let newDidSerialize = _assign({}, didSerialize);\n      newDidSerialize[model.modelName] = newDidSerialize[model.modelName] || {};\n      newDidSerialize[model.modelName][model.id] = true;\n\n      this.getKeysForIncluded().forEach((key) => {\n        let associatedResource = model[key];\n        if (!_get(newDidSerialize, `${associatedResource.modelName}.${associatedResource.id}`)) {\n          let [ associatedResourceHash ] = this.getHashForResource(associatedResource, true, newDidSerialize, true);\n          let formattedKey = this.keyForEmbeddedRelationship(key);\n          attrs[formattedKey] = associatedResourceHash;\n\n          if (this.isModel(associatedResource)) {\n            let fk = `${camelize(key)}Id`;\n            delete attrs[fk];\n          }\n        }\n      });\n\n      return attrs;\n    } else {\n      return this._maybeAddAssociationIds(model, attrs);\n    }\n  }\n\n  /**\n   * @method _attrsForModel\n   * @param model\n   * @private\n   */\n  _attrsForModel(model) {\n    let attrs = {};\n\n    if (this.attrs) {\n      attrs = this.attrs.reduce((memo, attr) => {\n        memo[attr] = model[attr];\n        return memo;\n      }, {});\n    } else {\n      attrs = _assign(attrs, model.attrs);\n    }\n\n    // Remove fks\n    model.fks.forEach(key => delete attrs[key]);\n\n    return this._formatAttributeKeys(attrs);\n  }\n\n  /**\n   * @method _maybeAddAssociationIds\n   * @param model\n   * @param attrs\n   * @private\n   */\n  _maybeAddAssociationIds(model, attrs) {\n    let newHash = _assign({}, attrs);\n\n    if (this.serializeIds === 'always') {\n      model.associationKeys.forEach((key) => {\n        let association = model[key];\n        if (this.isCollection(association)) {\n          let formattedKey = this.keyForRelationshipIds(key);\n          newHash[formattedKey] = model[key].models.map((m) => m.id);\n        } else if (association) {\n          let formattedKey = this.keyForForeignKey(key);\n          newHash[formattedKey] = model[key].id;\n        }\n      });\n    } else if (this.serializeIds === 'included') {\n      this.getKeysForIncluded().forEach((key) => {\n        let association = model[key];\n        if (this.isCollection(association)) {\n          let formattedKey = this.keyForRelationshipIds(key);\n          newHash[formattedKey] = model[key].models.map((m) => m.id);\n        } else if (association) {\n          let formattedKey = this.keyForForeignKey(key);\n          newHash[formattedKey] = model[key].id;\n        }\n      });\n    }\n\n    return newHash;\n  }\n\n  /**\n   * Used to customize how a model’s attribute is\n   * formatted in your JSON payload.\n   * @method keyForAttribute\n   * @param attr\n   * @public\n   */\n  keyForAttribute(attr) {\n    return attr;\n  }\n\n  /**\n   * Use this hook to format the key for collections\n   * related to this model.\n   *\n   * For example, if you're serializing an author that\n   * side loads many `blogPosts`, you would get `blogPost`\n   * as an argument, and whatever you return would\n   * end up as the collection key in your JSON:\n   *\n   * keyForRelationship(type) {\n   *   return dasherize(type);\n   * }\n   *\n   * {\n   *   author: {...},\n   *   'blog-posts': [...]\n   * }\n   * @method keyForRelationship\n   * @param modelName\n   * @public\n   */\n  keyForRelationship(modelName) {\n    return camelize(pluralize(modelName));\n  }\n\n  /**\n   * @method keyForEmbeddedRelationship\n   * @param attributeName\n   * @public\n   */\n  keyForEmbeddedRelationship(attributeName) {\n    return camelize(attributeName);\n  }\n\n  /**\n   * Use this hook to format the key for relationship ids\n   * in this model's JSON representation.\n   *\n   * For example, if you're serializing an author that\n   * side loads many `blogPosts`, you would get `blogPost`\n   * as an argument, and whatever you return would\n   * end up as part of the `author` JSON:\n   *\n   * keyForRelationshipIds(type) {\n   *   return dasherize(type) + '-ids';\n   * }\n   *\n   * {\n   *   author: {\n   *     ...,\n   *     'blog-post-ids': [1, 2, 3]\n   *   },\n   *   'blog-posts': [...]\n   * }\n   * @method keyForRelationshipIds\n   * @param modelName\n   * @public\n   */\n  keyForRelationshipIds(relationshipName) {\n    return `${singularize(camelize(relationshipName))}Ids`;\n  }\n\n  keyForForeignKey(relationshipName) {\n    return `${camelize(relationshipName)}Id`;\n  }\n\n  /**\n   * This method is used by the POST and PUT shorthands. These shorthands\n   * expect a valid JSON:API document as part of the request, so that\n   * they know how to create or update the appropriate resouce. The normalize\n   * method allows you to transform your request body into a JSON:API\n   * document, which lets you take advantage of the shorthands when you\n   * otherwise may not be able to.\n   *\n   * Note that this method is a noop if you’re using JSON:API already,\n   * since request payloads sent along with POST and PUT requests will\n   * already be in the correct format.\n   * @method normalize\n   * @param json\n   * @public\n   */\n  normalize(json) {\n    return json;\n  }\n\n  /**\n   * @method isModel\n   * @param object\n   * @return {Boolean}\n   * @public\n   */\n  isModel(object) {\n    return object instanceof Model;\n  }\n\n  /**\n   * @method isCollection\n   * @param object\n   * @return {Boolean}\n   * @public\n   */\n  isCollection(object) {\n    return object instanceof Collection;\n  }\n\n  /**\n   * @method isModelOrCollection\n   * @param object\n   * @return {Boolean}\n   * @public\n   */\n  isModelOrCollection(object) {\n    return this.isModel(object) || this.isCollection(object);\n  }\n\n  /**\n   * @method serializerFor\n   * @param type\n   * @public\n   */\n  serializerFor(type) {\n    return this.registry.serializerFor(type);\n  }\n\n  getKeysForIncluded() {\n    return _isFunction(this.include) ? this.include(this.request) : this.include;\n  }\n\n  /**\n   * @method _formatAttributeKeys\n   * @param attrs\n   * @private\n   */\n  _formatAttributeKeys(attrs) {\n    let formattedAttrs = {};\n\n    for (let key in attrs) {\n      let formattedKey = this.keyForAttribute(key);\n      formattedAttrs[formattedKey] = attrs[key];\n    }\n\n    return formattedAttrs;\n  }\n}\n\n// Defaults\nSerializer.prototype.include = [];\nSerializer.prototype.root = true;\nSerializer.prototype.embed = false;\nSerializer.prototype.serializeIds = 'included'; // can be 'included', 'always', or 'never'\n\nSerializer.extend = extend;\n\nexport default Serializer;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/server.js":"/* eslint no-console: 0 */\n\nimport { pluralize, camelize } from './utils/inflector';\nimport { toCollectionName } from 'ember-cli-mirage/utils/normalize-name';\nimport Ember from 'ember';\nimport isAssociation from 'ember-cli-mirage/utils/is-association';\nimport Pretender from 'pretender';\nimport Db from './db';\nimport Schema from './orm/schema';\nimport assert from './assert';\nimport SerializerRegistry from './serializer-registry';\nimport RouteHandler from './route-handler';\n\nimport _pick from 'lodash/pick';\nimport _assign from 'lodash/assign';\nimport _find from 'lodash/find';\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _isInteger from 'lodash/isInteger';\n\nconst { RSVP: { Promise } } = Ember;\n\n/**\n * Creates a new Pretender instance.\n *\n * @method createPretender\n * @param {Server} server\n * @return {Object} A new Pretender instance.\n * @public\n */\nfunction createPretender(server) {\n  return new Pretender(function() {\n    this.passthroughRequest = function(verb, path, request) {\n      if (server.shouldLog()) {\n        console.log(`Passthrough request: ${verb.toUpperCase()} ${request.url}`);\n      }\n    };\n\n    this.handledRequest = function(verb, path, request) {\n      if (server.shouldLog()) {\n        console.log(`Mirage: [${request.status}] ${verb.toUpperCase()} ${request.url}`);\n        let { responseText } = request;\n        let loggedResponse;\n\n        try {\n          loggedResponse = JSON.parse(responseText);\n        } catch(e) {\n          loggedResponse = responseText;\n        }\n\n        console.log(loggedResponse);\n      }\n    };\n\n    this.unhandledRequest = function(verb, path) {\n      path = decodeURI(path);\n      assert(\n        `Your Ember app tried to ${verb} '${path}',\n         but there was no route defined to handle this request.\n         Define a route that matches this path in your\n         mirage/config.js file. Did you forget to add your namespace?`\n      );\n    };\n  });\n}\n\nconst defaultRouteOptions = {\n  coalesce: false,\n  timing: undefined\n};\n\nconst defaultPassthroughs = [\n  'http://localhost:0/chromecheckurl', // mobile chrome\n  'http://localhost:30820/socket.io' // electron\n];\nexport { defaultPassthroughs };\n\n/**\n * Determine if the object contains a valid option.\n *\n * @method isOption\n * @param {Object} option An object with one option value pair.\n * @return {Boolean} True if option is a valid option, false otherwise.\n * @private\n */\nfunction isOption(option) {\n  if (!option || typeof option !== 'object') {\n    return false;\n  }\n\n  let allOptions = Object.keys(defaultRouteOptions);\n  let optionKeys = Object.keys(option);\n  for (let i = 0; i < optionKeys.length; i++) {\n    let key = optionKeys[i];\n    if (allOptions.indexOf(key) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Extract arguments for a route.\n *\n * @method extractRouteArguments\n * @param {Array} args Of the form [options], [object, code], [function, code]\n * [shorthand, options], [shorthand, code, options]\n * @return {Array} [handler (i.e. the function, object or shorthand), code,\n * options].\n * @private\n */\nfunction extractRouteArguments(args) {\n  let [ lastArg ] = args.splice(-1);\n  if (isOption(lastArg)) {\n    lastArg = _assign({}, defaultRouteOptions, lastArg);\n  } else {\n    args.push(lastArg);\n    lastArg = defaultRouteOptions;\n  }\n  let t = 2 - args.length;\n  while (t-- > 0) {\n    args.push(undefined);\n  }\n  args.push(lastArg);\n  return args;\n}\n\n/**\n *\n *\n * @class Server\n * @public\n */\nexport default class Server {\n\n  /**\n   * Build the new server object.\n   *\n   * @constructor\n   * @public\n   */\n  constructor(options = {}) {\n    this.config(options);\n  }\n\n  config(config = {}) {\n    let didOverrideConfig = (config.environment && (this.environment && (this.environment !== config.environment)));\n    assert(!didOverrideConfig,\n    'You cannot modify Mirage\\'s environment once the server is created');\n    this.environment = config.environment || 'development';\n\n    this.options = config;\n\n    this.timing = this.timing || config.timing || 400;\n    this.namespace = this.namespace || config.namespace || '';\n    this.urlPrefix = this.urlPrefix || config.urlPrefix || '';\n\n    this._defineRouteHandlerHelpers();\n\n    this.db = this.db || new Db();\n    if (this.schema) {\n      this.schema.registerModels(config.models);\n      this.serializerOrRegistry.registerSerializers(config.serializers || {});\n    } else {\n      this.schema = new Schema(this.db, config.models);\n      this.serializerOrRegistry = new SerializerRegistry(this.schema, config.serializers);\n    }\n\n    let hasFactories = this._hasModulesOfType(config, 'factories');\n    let hasDefaultScenario = config.scenarios && config.scenarios.hasOwnProperty('default');\n\n    this.pretender = this.pretender || createPretender(this);\n\n    if (config.baseConfig) {\n      this.loadConfig(config.baseConfig);\n    }\n\n    if (this.isTest()) {\n      if (config.testConfig) {\n        this.loadConfig(config.testConfig);\n      }\n\n      window.server = this; // TODO: Better way to inject server into test env\n    }\n\n    if (this.isTest() && hasFactories) {\n      this.loadFactories(config.factories);\n    } else if (!this.isTest() && hasDefaultScenario) {\n      this.loadFactories(config.factories);\n      config.scenarios.default(this);\n    } else {\n      this.loadFixtures();\n    }\n\n    if (config.useDefaultPassthroughs) {\n      this._configureDefaultPassthroughs();\n    }\n  }\n\n  /**\n   * Determines if the current environment is the testing environment.\n   *\n   * @method isTest\n   * @return {Boolean} True if the environment is 'test', false otherwise.\n   * @public\n   */\n  isTest() {\n    return this.environment === 'test';\n  }\n\n  /**\n   * Determines if the server should log.\n   *\n   * @method shouldLog\n   * @return The value of this.logging if defined, or false if in the testing environment,\n   * true otherwise.\n   * @public\n   */\n  shouldLog() {\n    return typeof this.logging !== 'undefined' ? this.logging : !this.isTest();\n  }\n\n  /**\n   * Load the configuration given, setting timing to 0 if in the test\n   * environment.\n   *\n   * @method loadConfig\n   * @param {Object} config The configuration to load.\n   * @public\n   */\n  loadConfig(config) {\n    config.call(this);\n    this.timing = this.isTest() ? 0 : (this.timing || 0);\n  }\n\n  /**\n   * Whitelist requests to the specified paths and allow them to pass through\n   * your Mirage server to the actual network layer.\n   *\n   * @method passthrough\n   * @param {String} [...paths] Any numer of paths to whitelist\n   * @param {Array} options Unused\n   * @public\n   */\n  passthrough(...paths) {\n    let verbs = ['get', 'post', 'put', 'delete', 'patch'];\n    let lastArg = paths[paths.length - 1];\n\n    if (paths.length === 0) {\n      // paths = ['http://localhost:7357'];\n      paths = ['/**', '/'];\n    } else if (Array.isArray(lastArg)) {\n      verbs = paths.pop();\n    }\n\n    verbs.forEach((verb) => {\n      paths.forEach((path) => {\n        let fullPath = this._getFullPath(path);\n        this.pretender[verb](fullPath, this.pretender.passthrough);\n      });\n    });\n  }\n\n  /**\n   * Load the all or only the specified fixtures into Mirage's database.\n   *\n   * @method loadFixtures\n   * @param {String} [...args] The name of the fixture to load.\n   * @public\n   */\n  loadFixtures(...args) {\n    let { fixtures } = this.options;\n    if (args.length) {\n      let camelizedArgs = args.map(camelize);\n      fixtures = _pick(fixtures, ...camelizedArgs);\n    }\n\n    this.db.loadData(fixtures);\n  }\n\n  /*\n    Factory methods\n  */\n\n  /**\n   * Load factories into Mirage's database.\n   *\n   * @method loadFactories\n   * @param {Object} factoryMap\n   * @public\n   */\n  loadFactories(factoryMap = {}) {\n    // Store a reference to the factories\n    let currentFactoryMap = this._factoryMap || {};\n    this._factoryMap = _assign(currentFactoryMap, factoryMap);\n\n    // Create a collection for each factory\n    Object.keys(factoryMap).forEach((type) => {\n      let collectionName = toCollectionName(type);\n      this.db.createCollection(collectionName);\n    });\n  }\n\n  /**\n   * Get the factory for a given type.\n   *\n   * @method factoryFor\n   * @param {String} type\n   * @private\n   */\n  factoryFor(type) {\n    let camelizedType = camelize(type);\n\n    if (this._factoryMap && this._factoryMap[camelizedType]) {\n      return this._factoryMap[camelizedType];\n    }\n  }\n\n  build(type, ...traitsAndOverrides) {\n    let traits = traitsAndOverrides.filter((arg) => arg && typeof arg === 'string');\n    let overrides = _find(traitsAndOverrides, (arg) => _isPlainObject(arg));\n    let camelizedType = camelize(type);\n\n    // Store sequence for factory type as instance variable\n    this.factorySequences = this.factorySequences || {};\n    this.factorySequences[camelizedType] = this.factorySequences[camelizedType] + 1 || 0;\n\n    let OriginalFactory = this.factoryFor(type);\n    if (OriginalFactory) {\n      OriginalFactory = OriginalFactory.extend({});\n      let attrs = OriginalFactory.attrs || {};\n      this._validateTraits(traits, OriginalFactory, type);\n      let mergedExtensions = this._mergeExtensions(attrs, traits, overrides);\n      this._mapAssociationsFromAttributes(type, attrs);\n      this._mapAssociationsFromAttributes(type, mergedExtensions);\n\n      let Factory = OriginalFactory.extend(mergedExtensions);\n      let factory = new Factory();\n\n      let sequence = this.factorySequences[camelizedType];\n      return factory.build(sequence);\n    } else {\n      return overrides;\n    }\n  }\n\n  buildList(type, amount, ...traitsAndOverrides) {\n    assert(_isInteger(amount), `second argument has to be an integer, you passed: ${typeof amount}`);\n\n    let list = [];\n\n    for (let i = 0; i < amount; i++) {\n      list.push(this.build(type, ...traitsAndOverrides));\n    }\n\n    return list;\n  }\n\n  create(type, ...options) {\n    // When there is a Model defined, we should return an instance\n    // of it instead of returning the bare attributes.\n    let traits = options.filter((arg) => arg && typeof arg === 'string');\n    let overrides = _find(options, (arg) => _isPlainObject(arg));\n    let collectionFromCreateList = _find(options, (arg) => arg && Array.isArray(arg));\n\n    let attrs = this.build(type, ...traits, overrides);\n    let modelOrRecord;\n\n    if (this.schema && this.schema[toCollectionName(type)]) {\n      let modelClass = this.schema[toCollectionName(type)];\n\n      modelOrRecord = modelClass.create(attrs);\n\n    } else {\n      let collection, collectionName;\n\n      if (collectionFromCreateList) {\n        collection = collectionFromCreateList;\n      } else {\n        collectionName = this.schema ? toCollectionName(type) : pluralize(type);\n        collection = this.db[collectionName];\n      }\n\n      assert(collection, `You called server.create(${type}) but no model or factory was found. Try \\`ember g mirage-model ${type}\\`.`);\n      modelOrRecord = collection.insert(attrs);\n    }\n\n    let OriginalFactory = this.factoryFor(type);\n    if (OriginalFactory) {\n      OriginalFactory.extractAfterCreateCallbacks({ traits }).forEach((afterCreate) => {\n        afterCreate(modelOrRecord, this);\n      });\n    }\n\n    return modelOrRecord;\n  }\n\n  createList(type, amount, ...traitsAndOverrides) {\n    assert(_isInteger(amount), `second argument has to be an integer, you passed: ${typeof amount}`);\n\n    let list = [];\n    let collectionName = this.schema ? toCollectionName(type) : pluralize(type);\n    let collection = this.db[collectionName];\n\n    for (let i = 0; i < amount; i++) {\n      list.push(this.create(type, ...traitsAndOverrides, collection));\n    }\n\n    return list;\n  }\n\n  shutdown() {\n    this.pretender.shutdown();\n    if (this.environment === 'test') {\n      window.server = undefined;\n    }\n  }\n\n  resource(resourceName, { only, except } = {}) {\n    only = only || [];\n    except = except || [];\n\n    if (only.length > 0 && except.length > 0) {\n      throw 'cannot use both :only and :except options';\n    }\n\n    let actionsMethodsAndsPathsMappings = {\n      index: { methods: ['get'], path: `/${resourceName}` },\n      show: { methods: ['get'], path: `/${resourceName}/:id` },\n      create: { methods: ['post'], path: `/${resourceName}` },\n      update: { methods: ['put', 'patch'], path: `/${resourceName}/:id` },\n      delete: { methods: ['del'], path: `/${resourceName}/:id` }\n    };\n\n    let allActions = Object.keys(actionsMethodsAndsPathsMappings);\n    let actions = only.length > 0 && only\n                  || except.length > 0 && allActions.filter((action) => (except.indexOf(action) === -1))\n                  || allActions;\n\n    actions.forEach((action) => {\n      let methodsWithPath = actionsMethodsAndsPathsMappings[action];\n\n      methodsWithPath.methods.forEach((method) => this[method](methodsWithPath.path));\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _defineRouteHandlerHelpers() {\n    [['get'], ['post'], ['put'], ['delete', 'del'], ['patch'], ['head']].forEach(([verb, alias]) => {\n      this[verb] = (path, ...args) => {\n        let [ rawHandler, customizedCode, options ] = extractRouteArguments(args);\n        this._registerRouteHandler(verb, path, rawHandler, customizedCode, options);\n      };\n\n      if (alias) {\n        this[alias] = this[verb];\n      }\n    });\n  }\n\n  _serialize(body) {\n    if (typeof body === 'string') {\n      return body;\n    } else if (body) {\n      return JSON.stringify(body);\n    } else {\n      return '{\"error\": \"not found\"}';\n    }\n  }\n\n  _registerRouteHandler(verb, path, rawHandler, customizedCode, options) {\n\n    let routeHandler = new RouteHandler({\n      schema: this.schema,\n      verb, rawHandler, customizedCode, options, path,\n      serializerOrRegistry: this.serializerOrRegistry\n    });\n\n    let fullPath = this._getFullPath(path);\n    let timing = options.timing !== undefined ? options.timing : (() => this.timing);\n\n    this.pretender[verb](\n      fullPath,\n      (request) => {\n        return new Promise(resolve => {\n          Promise.resolve(routeHandler.handle(request)).then(mirageResponse => {\n            let [ code, headers, response ] = mirageResponse;\n            resolve([ code, headers, this._serialize(response) ]);\n          });\n        });\n      },\n      timing\n    );\n  }\n\n  /**\n   *\n   * @private\n   */\n  _hasModulesOfType(modules, type) {\n    let modulesOfType = modules[type];\n    return modulesOfType ? Object.keys(modulesOfType).length > 0 : false;\n  }\n\n  /**\n   * Builds a full path for Pretender to monitor based on the `path` and\n   * configured options (`urlPrefix` and `namespace`).\n   *\n   * @private\n   */\n  _getFullPath(path) {\n    path = path[0] === '/' ? path.slice(1) : path;\n    let fullPath = '';\n    let urlPrefix = this.urlPrefix ? this.urlPrefix.trim() : '';\n    let namespace = '';\n\n    // if there is a urlPrefix and a namespace\n    if (this.urlPrefix && this.namespace) {\n      if (this.namespace[0] === '/' && this.namespace[this.namespace.length - 1] === '/') {\n        namespace = this.namespace.substring(0, this.namespace.length - 1).substring(1);\n      }\n\n      if (this.namespace[0] === '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = this.namespace.substring(1);\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] === '/') {\n        namespace = this.namespace.substring(0, this.namespace.length - 1);\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = this.namespace;\n      }\n    }\n\n    // if there is a namespace and no urlPrefix\n    if (this.namespace && !this.urlPrefix) {\n      if (this.namespace[0] === '/' && this.namespace[this.namespace.length - 1] === '/') {\n        namespace = this.namespace.substring(0, this.namespace.length - 1);\n      }\n\n      if (this.namespace[0] === '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = this.namespace;\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] === '/') {\n        let namespaceSub = this.namespace.substring(0, this.namespace.length - 1);\n        namespace = `/${namespaceSub}`;\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = `/${this.namespace}`;\n      }\n    }\n\n    // if no namespace\n    if (!this.namespace) {\n      namespace = '';\n    }\n\n    // check to see if path is a FQDN. if so, ignore any urlPrefix/namespace that was set\n    if (/^https?:\\/\\//.test(path)) {\n      fullPath += path;\n    } else {\n      // otherwise, if there is a urlPrefix, use that as the beginning of the path\n      if (urlPrefix.length) {\n        fullPath += (urlPrefix[urlPrefix.length - 1] === '/') ? urlPrefix : `${urlPrefix}/`;\n      }\n\n      // add the namespace to the path\n      fullPath += namespace;\n\n      // add a trailing slash to the path if it doesn't already contain one\n      if (fullPath[fullPath.length - 1] !== '/') {\n        fullPath += '/';\n      }\n\n      // finally add the configured path\n      fullPath += path;\n\n      // if we're making a same-origin request, ensure a / is prepended and\n      // dedup any double slashes\n      if (!/^https?:\\/\\//.test(fullPath)) {\n        fullPath = `/${fullPath}`;\n        fullPath = fullPath.replace(/\\/+/g, '/');\n      }\n    }\n\n    return fullPath;\n  }\n\n  /**\n   *\n   * @private\n   */\n  _configureDefaultPassthroughs() {\n    defaultPassthroughs.forEach((passthroughUrl) => {\n      this.passthrough(passthroughUrl);\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _validateTraits(traits, factory, type) {\n    traits.forEach((traitName) => {\n      if (!factory.isTrait(traitName)) {\n        throw new Error(`'${traitName}' trait is not registered in '${type}' factory`);\n      }\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _mergeExtensions(attrs, traits, overrides) {\n    let allExtensions = traits.map((traitName) => {\n      return attrs[traitName].extension;\n    });\n    allExtensions.push(overrides || {});\n    return allExtensions.reduce((accum, extension) => {\n      return _assign(accum, extension);\n    }, {});\n  }\n\n  /**\n   *\n   * @private\n   */\n  _mapAssociationsFromAttributes(modelType, attributes) {\n    Object.keys(attributes || {}).filter((attr) => {\n      return isAssociation(attributes[attr]);\n    }).forEach((attr) => {\n      let association = attributes[attr];\n      let associationName = this._fetchAssociationNameFromModel(modelType, attr);\n      let foreignKey = `${camelize(attr)}Id`;\n      attributes[foreignKey] = this.create(associationName, ...association.traitsAndOverrides).id;\n      delete attributes[attr];\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _fetchAssociationNameFromModel(modelType, associationAttribute) {\n    let model = this.schema.modelFor(modelType);\n    if (!model) {\n      throw new Error(`Model not registered: ${modelType}`);\n    }\n\n    let association = model.class.findBelongsToAssociation(associationAttribute);\n    if (!association) {\n      throw new Error(`You're using the \\`association\\` factory helper on the '${associationAttribute}' attribute of your ${modelType} factory, but that attribute is not a \\`belongsTo\\` association. Read the Factories docs for more information: http://www.ember-cli-mirage.com/docs/v0.2.x/factories/#factories-and-relationships`);\n    }\n    return camelize(association.modelName);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/trait.js":"let trait = function(extension) {\n  let __isTrait__ = true;\n  return {\n    extension,\n    __isTrait__\n  };\n};\n\nexport default trait;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/config/environment.js":"/* eslint-env node */\n'use strict';\nvar fs = require('fs');\n\nfunction usingProxy() {\n  var usingProxyArg = !!process.argv.filter(function (arg) {\n    return arg.indexOf('--proxy') === 0 || arg.indexOf('-pr') === 0 || arg.indexOf('-pxy') === 0;\n  }).length;\n\n  var hasGeneratedProxies = false;\n  var proxiesDir = process.env.PWD + '/server/proxies';\n  try {\n    fs.lstatSync(proxiesDir);\n    hasGeneratedProxies = true;\n  } catch (e) {}\n\n  return usingProxyArg || hasGeneratedProxies;\n}\n\nmodule.exports = function(environment, appConfig) {\n  appConfig['ember-cli-mirage'] = appConfig['ember-cli-mirage'] || {};\n  appConfig['ember-cli-mirage']['usingProxy'] = usingProxy();\n  appConfig['ember-cli-mirage']['useDefaultPassthroughs'] = true;\n\n  return {};\n};"}