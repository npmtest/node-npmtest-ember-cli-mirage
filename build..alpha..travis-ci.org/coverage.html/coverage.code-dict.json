{"/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/test.js":"/* istanbul instrument in package npmtest_ember_cli_mirage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/lib.npmtest_ember_cli_mirage.js":"/* istanbul instrument in package npmtest_ember_cli_mirage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ember_cli_mirage = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ember_cli_mirage = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ember-cli-mirage && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ember_cli_mirage */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ember_cli_mirage\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ember_cli_mirage.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ember_cli_mirage.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ember_cli_mirage.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ember_cli_mirage.__dirname + '/lib.npmtest_ember_cli_mirage.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/index.js":"/* eslint-env node */\n'use strict';\nvar path = require('path');\nvar mergeTrees = require('broccoli-merge-trees');\nvar Funnel = require('broccoli-funnel');\n\nmodule.exports = {\n  name: 'ember-cli-mirage',\n\n  options: {\n    nodeAssets: {\n      'route-recognizer': npmAsset({\n        path: 'dist/route-recognizer.js',\n        sourceMap: 'dist/route-recognizer.js.map'\n      }),\n      'fake-xml-http-request': npmAsset('fake_xml_http_request.js'),\n      'pretender': npmAsset('pretender.js'),\n      'faker': npmAsset('build/build/faker.js')\n    }\n  },\n\n  included: function included() {\n    var app;\n\n    // If the addon has the _findHost() method (in ember-cli >= 2.7.0), we'll just\n    // use that.\n    if (typeof this._findHost === 'function') {\n      app = this._findHost();\n    } else {\n      // Otherwise, we'll use this implementation borrowed from the _findHost()\n      // method in ember-cli.\n      var current = this;\n      do {\n        app = current.app || app;\n      } while (current.parent.parent && (current = current.parent));\n    }\n\n    this.app = app;\n    this.addonConfig = this.app.project.config(app.env)['ember-cli-mirage'] || {};\n    this.addonBuildConfig = this.app.options['ember-cli-mirage'] || {};\n\n    // Call super after initializing config so we can use _shouldIncludeFiles for the node assets\n    this._super.included.apply(this, arguments);\n\n    if (this.addonBuildConfig.directory) {\n      this.mirageDirectory = this.addonBuildConfig.directory;\n    } else if (this.addonConfig.directory) {\n      this.mirageDirectory = this.addonConfig.directory;\n    } else if (app.project.pkg['ember-addon'] && !app.project.pkg['ember-addon'].paths) {\n      this.mirageDirectory = path.resolve(app.project.root, path.join('tests', 'dummy', 'mirage'));\n    } else {\n      this.mirageDirectory = path.join(this.app.project.root, '/mirage');\n    }\n\n    if (this._shouldIncludeFiles()) {\n      app.import('vendor/ember-cli-mirage/pretender-shim.js', {\n        type: 'vendor',\n        exports: { 'pretender': ['default'] }\n      });\n    }\n  },\n\n  blueprintsPath: function() {\n    return path.join(__dirname, 'blueprints');\n  },\n\n  treeFor: function(name) {\n    if (!this._shouldIncludeFiles()) {\n      return;\n    }\n\n    return this._super.treeFor.apply(this, arguments);\n  },\n\n  _lintMirageTree: function(mirageTree) {\n    var lintedMirageTrees;\n    // _eachProjectAddonInvoke was added in ember-cli@2.5.0\n    // this conditional can be removed when we no longer support\n    // versions older than 2.5.0\n    if (this._eachProjectAddonInvoke) {\n      lintedMirageTrees = this._eachProjectAddonInvoke('lintTree', ['mirage', mirageTree]);\n    } else {\n      lintedMirageTrees = this.project.addons.map(function(addon) {\n        if (addon.lintTree) {\n          return addon.lintTree('mirage', mirageTree);\n        }\n      }).filter(Boolean);\n    }\n\n    var lintedMirage = mergeTrees(lintedMirageTrees, {\n      overwrite: true,\n      annotation: 'TreeMerger (mirage-lint)'\n    });\n\n    return new Funnel(lintedMirage, {\n      destDir: 'tests/mirage/'\n    });\n  },\n\n  treeForApp: function(appTree) {\n    var trees = [ appTree ];\n    var mirageFilesTree = new Funnel(this.mirageDirectory, {\n      destDir: 'mirage'\n    });\n    trees.push(mirageFilesTree);\n\n    if (this.hintingEnabled()) {\n      trees.push(this._lintMirageTree(mirageFilesTree));\n    }\n\n    return mergeTrees(trees);\n  },\n\n  _shouldIncludeFiles: function() {\n    if (process.env.EMBER_CLI_FASTBOOT) {\n      return false;\n    }\n\n    var environment = this.app.env;\n    var enabledInProd = environment === 'production' && this.addonConfig.enabled;\n    var explicitExcludeFiles = this.addonConfig.excludeFilesFromBuild;\n    if (enabledInProd && explicitExcludeFiles) {\n      throw new Error('Mirage was explicitly enabled in production, but its files were excluded '\n                      + 'from the build. Please, use only ENV[\\'ember-cli-mirage\\'].enabled in '\n                      + 'production environment.');\n    }\n    return enabledInProd || (environment && environment !== 'production' && explicitExcludeFiles !== true);\n  }\n};\n\nfunction npmAsset(filePath) {\n  return function() {\n    return {\n      enabled: this._shouldIncludeFiles(),\n      import: [filePath]\n    };\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/.eslintrc.js":"module.exports = {\n  root: true,\n  parserOptions: {\n    ecmaVersion: 6,\n    sourceType: 'module'\n  },\n  extends: [\n    'eslint:recommended',\n    'plugin:ember-suave/recommended'\n  ],\n  env: {\n    'browser': true\n  },\n  rules: {\n    'camelcase': 0,\n    'ember-suave/no-direct-property-access': 0,\n    'ember-suave/prefer-destructuring': 0,\n    'object-curly-spacing': 0,\n    'quotes': 0,\n    'array-bracket-spacing': 0,\n    'no-var': 0,\n    'object-shorthand': 0,\n    'arrow-parens': 0,\n    'no-unused-vars': ['error', { 'args': 'none' }]\n  },\n  globals: {\n    faker: true,\n    server: true,\n    $: true\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/assert.js":"/* eslint no-console: 0 */\nlet errorProps = [\n  'description',\n  'fileName',\n  'lineNumber',\n  'message',\n  'name',\n  'number',\n  'stack'\n];\n\nexport default function assert(bool, text) {\n  if (typeof bool === 'string' && !text) {\n    throw new MirageError(bool);\n  }\n\n  if (!bool) {\n    throw new MirageError(text.replace(/^ +/gm, '') || 'Assertion failed');\n  }\n}\n\n/**\n  @public\n  Copied from ember-metal/error\n*/\nexport function MirageError() {\n  let tmp = Error.apply(this, arguments);\n\n  for (let idx = 0; idx < errorProps.length; idx++) {\n    let prop = errorProps[idx];\n\n    if (['description', 'message', 'stack'].indexOf(prop) > -1) {\n      this[prop] = `Mirage: ${tmp[prop]}`;\n    } else {\n      this[prop] = tmp[prop];\n    }\n  }\n\n  console.error(this.message);\n  console.error(this);\n}\n\nMirageError.prototype = Object.create(Error.prototype);\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/association.js":"let association = function(...traitsAndOverrides) {\n  let __isAssociation__ = true;\n  return {\n    __isAssociation__,\n    traitsAndOverrides\n  };\n};\n\nexport default association;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/db-collection.js":"import _assign from 'lodash/assign';\nimport _map from 'lodash/map';\nimport _isEqual from 'lodash/isEqual';\nimport _sortBy from 'lodash/sortBy';\n\nfunction duplicate(data) {\n  if (Array.isArray(data)) {\n    return data.map(duplicate);\n  } else {\n    return _assign({}, data);\n  }\n}\n\nfunction isNumber(n) {\n  return (+n).toString() === n.toString();\n}\n\n/**\n *  A collection of db records i.e. a database table.\n *  @class DbCollection\n *  @constructor\n *  @public\n */\nclass DbCollection {\n\n  constructor(name, initialData) {\n    this.name = name;\n    this._records = [];\n    this.identityManager = new IdentityManager();\n\n    if (initialData) {\n      this.insert(initialData);\n    }\n  }\n\n  /**\n   * Returns a copy of the data, to prevent inadvertent data manipulation.\n   * @method all\n   * @public\n   */\n  all() {\n    return duplicate(this._records);\n  }\n\n  /**\n   * Inserts `data` into the collection. `data` can be a single object\n   * or an array of objects. Returns the inserted record.\n   * @method insert\n   * @param data\n   * @public\n   */\n  insert(data) {\n    if (!Array.isArray(data)) {\n      return this._insertRecord(data);\n    } else {\n      // Need to sort in order to ensure IDs inserted in the correct order\n      let sorted = _sortBy(data, 'id');\n      return _map(sorted, (x) => this._insertRecord(x));\n    }\n  }\n\n  /**\n   * Returns a single record from the `collection` if `ids` is a single\n   * id, or an array of records if `ids` is an array of ids. Note\n   * each id can be an int or a string, but integer ids as strings\n   * (e.g. the string “1”) will be treated as integers.\n   * @method find\n   * @param ids\n   * @public\n   */\n  find(ids) {\n    if (Array.isArray(ids)) {\n      let records = this._findRecords(ids)\n        .filter(Boolean)\n        .map(duplicate); // Return a copy\n\n      return records;\n    } else {\n      let record = this._findRecord(ids);\n      if (!record) {\n        return null;\n      }\n\n      // Return a copy\n      return duplicate(record);\n    }\n  }\n\n  /**\n   * Returns the first model from `collection` that matches the\n   * key-value pairs in the `query` object. Note that a string\n   * comparison is used. `query` is a POJO.\n   * @method find\n   * @param query\n   * @public\n   */\n  findBy(query) {\n    let record = this._findRecordBy(query);\n    if (!record) {\n      return null;\n    }\n\n    // Return a copy\n    return duplicate(record);\n  }\n\n  /**\n   * Returns an array of models from `collection` that match the\n   * key-value pairs in the `query` object. Note that a string\n   * comparison is used. `query` is a POJO.\n   * @method where\n   * @param query\n   * @public\n   */\n  where(query) {\n    return this._findRecordsWhere(query).map(duplicate);\n  }\n\n  /**\n   * Finds the first record matching the provided query in\n   * `collection`, or creates a new record using a merge of the\n   * `query` and optional `attributesForCreate`.\n   * @method firstOrCreate\n   * @param query\n   * @param attributesForCreate\n   * @public\n   */\n  firstOrCreate(query, attributesForCreate = {}) {\n    let queryResult = this.where(query);\n    let [record] = queryResult;\n\n    if (record) {\n      return record;\n    } else {\n      let mergedAttributes = _assign(attributesForCreate, query);\n      let createdRecord = this.insert(mergedAttributes);\n\n      return createdRecord;\n    }\n  }\n\n  /**\n   * Updates one or more records in collection.\n   * If attrs is the only arg present, updates all records\n   * in the collection according to the key-value pairs in attrs.\n   * If target is present, restricts updates to those that\n   * match target. If target is a number or string, finds a\n   * single record whose id is target to update. If target is\n   * a POJO, queries collection for records that match the\n   * key-value pairs in target, and updates their attrs.\n   * Returns the updated record or records.\n   * @method update\n   * @param target\n   * @param attrs\n   * @public\n   */\n  update(target, attrs) {\n    let records;\n\n    if (typeof attrs === 'undefined') {\n      attrs = target;\n      let changedRecords = [];\n\n      this._records.forEach((record) => {\n        let oldRecord = _assign({}, record);\n\n        this._updateRecord(record, attrs);\n\n        if (!_isEqual(oldRecord, record)) {\n          changedRecords.push(record);\n        }\n      });\n\n      return changedRecords;\n\n    } else if (typeof target === 'number' || typeof target === 'string') {\n      let id = target;\n      let record = this._findRecord(id);\n\n      this._updateRecord(record, attrs);\n\n      return record;\n\n    } else if (Array.isArray(target)) {\n      let ids = target;\n      records = this._findRecords(ids);\n\n      records.forEach((record) => {\n        this._updateRecord(record, attrs);\n      });\n\n      return records;\n\n    } else if (typeof target === 'object') {\n      let query = target;\n      records = this._findRecordsWhere(query);\n\n      records.forEach((record) => {\n        this._updateRecord(record, attrs);\n      });\n\n      return records;\n    }\n  }\n\n  /**\n   * Removes one or more records in `collection`.\n   * If `target` is undefined, removes all records.\n   * If `target` is a number or string, removes a\n   * single record using `target` as id. If `target` is\n   * a POJO, queries `collection` for records that\n   * match the key-value pairs in `target`, and\n   * removes them from the collection.\n   * @method remove\n   * @param target\n   * @public\n   */\n  remove(target) {\n    let records;\n\n    if (typeof target === 'undefined') {\n      this._records = [];\n      this.identityManager.reset();\n\n    } else if (typeof target === 'number' || typeof target === 'string') {\n      let record = this._findRecord(target);\n      let index = this._records.indexOf(record);\n      this._records.splice(index, 1);\n\n    } else if (Array.isArray(target)) {\n      records = this._findRecords(target);\n      records.forEach((record) =>  {\n        let index = this._records.indexOf(record);\n        this._records.splice(index, 1);\n      });\n\n    } else if (typeof target === 'object') {\n      records = this._findRecordsWhere(target);\n      records.forEach((record) =>  {\n        let index = this._records.indexOf(record);\n        this._records.splice(index, 1);\n      });\n    }\n  }\n\n  /*\n    Private methods.\n\n    These return the actual db objects, whereas the public\n    API query methods return copies.\n  */\n\n  /**\n   * @method _findRecord\n   * @param id\n   * @private\n   */\n  _findRecord(id) {\n    id = id.toString();\n\n    let [record] = this._records.filter((obj) => obj.id === id);\n\n    return record;\n  }\n\n  /**\n   * @method _findRecordBy\n   * @param query\n   * @private\n   */\n  _findRecordBy(query) {\n    return this._findRecordsWhere(query)[0];\n  }\n\n  /**\n   * @method _findRecords\n   * @param ids\n   * @private\n   */\n  _findRecords(ids) {\n    return ids.map(this._findRecord, this);\n  }\n\n  /**\n   * @method _findRecordsWhere\n   * @param query\n   * @private\n   */\n  _findRecordsWhere(query) {\n    let records = this._records;\n\n    function defaultQueryFunction(record) {\n      let keys = Object.keys(query);\n\n      return keys.every(function(key) {\n        return String(record[key]) === String(query[key]);\n      });\n    }\n\n    let queryFunction = typeof query === 'object' ? defaultQueryFunction : query;\n\n    return records.filter(queryFunction);\n  }\n\n  /**\n   * @method _insertRecord\n   * @param data\n   * @private\n   */\n  _insertRecord(data) {\n    let attrs = duplicate(data);\n\n    if (attrs && (attrs.id === undefined || attrs.id === null)) {\n      attrs.id = this.identityManager.fetch();\n    } else {\n      attrs.id = attrs.id.toString();\n\n      this.identityManager.set(attrs.id);\n    }\n\n    this._records.push(attrs);\n\n    return duplicate(attrs);\n  }\n\n  /**\n   * @method _updateRecord\n   * @param record\n   * @param attrs\n   * @private\n   */\n  _updateRecord(record, attrs) {\n    let targetId = (attrs && attrs.hasOwnProperty('id')) ? attrs.id.toString() : null;\n    let currentId = record.id;\n\n    if (targetId && currentId !== targetId) {\n      throw new Error('Updating the ID of a record is not permitted');\n    }\n\n    for (let attr in attrs) {\n      if (attr === 'id') {\n        continue;\n      }\n\n      record[attr] = attrs[attr];\n    }\n  }\n}\n\nclass IdentityManager {\n  constructor() {\n    this._nextId = 1;\n    this._ids = {};\n  }\n\n  get() {\n    return this._nextId;\n  }\n\n  set(n) {\n    if (this._ids[n]) {\n      throw new Error(`Attempting to use the ID ${n}, but it's already been used`);\n    }\n\n    if (isNumber(n) && +n >= this._nextId) {\n      this._nextId = +n + 1;\n    }\n\n    this._ids[n] = true;\n  }\n\n  inc() {\n    let nextValue = this.get() + 1;\n\n    this._nextId = nextValue;\n\n    return nextValue;\n  }\n\n  fetch() {\n    let id = this.get();\n\n    this._ids[id] = true;\n\n    this.inc();\n\n    return id.toString();\n  }\n\n  reset() {\n    this._nextId = 1;\n    this._ids = {};\n  }\n}\n\nexport default DbCollection;\n\nexport { IdentityManager };\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/db.js":"import DbCollection from './db-collection';\n\n/**\n * The db, an identity map.\n * @class Db\n * @constructor\n * @public\n */\nclass Db {\n\n  constructor(initialData) {\n    this._collections = [];\n\n    if (initialData) {\n      this.loadData(initialData);\n    }\n  }\n\n  /**\n   * @method loadData\n   * @param data\n   * @public\n   */\n  loadData(data) {\n    for (let key in data) {\n      this.createCollection(key, data[key]);\n    }\n  }\n\n  /**\n   * @method dump\n   * @public\n   */\n  dump() {\n    return this._collections.reduce((data, collection) => {\n      data[collection.name] = collection.all();\n\n      return data;\n    }, {});\n  }\n\n  /**\n   * @method createCollection\n   * @param name\n   * @param initialData\n   * @public\n   */\n  createCollection(name, initialData) {\n    if (!this[name]) {\n      let newCollection = new DbCollection(name, initialData);\n\n      Object.defineProperty(this, name, {\n        get() {\n          let recordsCopy = newCollection.all();\n\n          ['insert', 'find', 'findBy', 'where', 'update', 'remove', 'firstOrCreate']\n            .forEach(function(method) {\n              recordsCopy[method] = function() {\n                return newCollection[method](...arguments);\n              };\n            });\n\n          return recordsCopy;\n        }\n      });\n\n      this._collections.push(newCollection);\n\n    } else if (initialData) {\n      this[name].insert(initialData);\n    }\n\n    return this;\n  }\n\n  /**\n   * @method createCollections\n   * @param ...collections\n   * @public\n   */\n  createCollections(...collections) {\n    collections.forEach((c) => this.createCollection(c));\n  }\n\n  /**\n   * @method emptyData\n   * @public\n   */\n  emptyData() {\n    this._collections.forEach((c) => c.remove());\n  }\n}\n\nexport default Db;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/factory.js":"import _assign from 'lodash/assign';\nimport _isFunction from 'lodash/isFunction';\nimport _mapValues from 'lodash/mapValues';\nimport referenceSort from './utils/reference-sort';\nimport _isPlainObject from 'lodash/isPlainObject';\n\nlet Factory = function() {\n  this.build = function(sequence) {\n    let object = {};\n    let topLevelAttrs = _assign({}, this.attrs);\n    delete topLevelAttrs.afterCreate;\n    Object.keys(topLevelAttrs).forEach((attr) => {\n      if (Factory.isTrait.call(this, attr)) {\n        delete topLevelAttrs[attr];\n      }\n    });\n    let keys = sortAttrs(topLevelAttrs, sequence);\n\n    keys.forEach(function(key) {\n      let buildAttrs, buildSingleValue;\n\n      buildAttrs = function(attrs) {\n        return _mapValues(attrs, buildSingleValue);\n      };\n\n      buildSingleValue = (value) => {\n        if (Array.isArray(value)) {\n          return value.map(buildSingleValue);\n        } else if (_isPlainObject(value)) {\n          return buildAttrs(value);\n        } else if (_isFunction(value)) {\n          return value.call(topLevelAttrs, sequence);\n        } else {\n          return value;\n        }\n      };\n\n      let value = topLevelAttrs[key];\n      if (_isFunction(value)) {\n        object[key] = value.call(object, sequence);\n      } else {\n        object[key] = buildSingleValue(value);\n      }\n\n    });\n\n    return object;\n  };\n};\n\nFactory.extend = function(attrs) {\n  // Merge the new attributes with existing ones. If conflict, new ones win.\n  let newAttrs = _assign({}, this.attrs, attrs);\n\n  let Subclass = function() {\n    this.attrs = newAttrs;\n    Factory.call(this);\n  };\n\n  // Copy extend\n  Subclass.extend = Factory.extend;\n  Subclass.extractAfterCreateCallbacks = Factory.extractAfterCreateCallbacks;\n  Subclass.isTrait = Factory.isTrait;\n\n  // Store a reference on the class for future subclasses\n  Subclass.attrs = newAttrs;\n\n  return Subclass;\n};\n\nFactory.extractAfterCreateCallbacks = function({ traits } = {}) {\n  let afterCreateCallbacks = [];\n  let attrs = this.attrs || {};\n  let traitCandidates;\n\n  if (attrs.afterCreate) {\n    afterCreateCallbacks.push(attrs.afterCreate);\n  }\n\n  if (Array.isArray(traits)) {\n    traitCandidates = traits;\n  } else {\n    traitCandidates = Object.keys(attrs);\n  }\n\n  traitCandidates.filter((attr) => {\n    return this.isTrait(attr) && attrs[attr].extension.afterCreate;\n  }).forEach((attr) => {\n    afterCreateCallbacks.push(attrs[attr].extension.afterCreate);\n  });\n\n  return afterCreateCallbacks;\n};\n\nFactory.isTrait = function(attrName) {\n  let { attrs } = this;\n  return _isPlainObject(attrs[attrName]) && attrs[attrName].__isTrait__ === true;\n};\n\nfunction sortAttrs(attrs, sequence) {\n  let Temp = function() {};\n  let obj = new Temp();\n  let refs = [];\n  let property;\n\n  Object.keys(attrs).forEach(function(key) {\n    let value;\n    Object.defineProperty(obj.constructor.prototype, key, {\n      get() {\n        refs.push([property, key]);\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n      },\n      enumerable: false,\n      configurable: true\n    });\n  });\n\n  Object.keys(attrs).forEach(function(key) {\n    let value = attrs[key];\n    if (typeof value !== 'function') {\n      obj[key] = value;\n    }\n  });\n\n  Object.keys(attrs).forEach(function(key) {\n    let value = attrs[key];\n    property = key;\n\n    if (typeof value === 'function') {\n      obj[key] = value.call(obj, sequence);\n    }\n\n    refs.push([key]);\n  });\n\n  return referenceSort(refs);\n}\n\nexport default Factory;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/faker.js":"let list = {\n  random() {\n    let items = arguments.length > 0 ? arguments : [];\n\n    return function() {\n      return faker.random.arrayElement(items);\n    };\n  },\n\n  cycle() {\n    let items = arguments.length > 0 ? arguments : [];\n\n    return function(i) {\n      return items[i % items.length];\n    };\n  }\n};\n\nfaker.list = list;\n\nfaker.random.number.range = function(min, max) {\n  return function(/* i */) {\n    return Math.random() * (max - min) + min;\n  };\n};\n\nexport default faker;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/index.js":"import Factory from './factory';\nimport trait from './trait';\nimport association from './association';\nimport Response from './response';\nimport faker from './faker';\nimport Model from './orm/model';\nimport Collection from './orm/collection';\nimport Serializer from './serializer';\nimport ActiveModelSerializer from './serializers/active-model-serializer';\nimport JSONAPISerializer from './serializers/json-api-serializer';\nimport RestSerializer from './serializers/rest-serializer';\nimport HasMany from './orm/associations/has-many';\nimport BelongsTo from './orm/associations/belongs-to';\n\nfunction hasMany(...args) {\n  return new HasMany(...args);\n}\nfunction belongsTo(...args) {\n  return new BelongsTo(...args);\n}\n\nexport {\n  Factory,\n  trait,\n  association,\n  Response,\n  faker,\n  Model,\n  Collection,\n  Serializer,\n  ActiveModelSerializer,\n  JSONAPISerializer,\n  RestSerializer,\n  hasMany,\n  belongsTo\n};\n\nexport default {\n  Factory,\n  Response,\n  hasMany,\n  belongsTo\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/response.js":"export default class Response {\n\n  constructor(code, headers = {}, data = {}) {\n    this.code = code;\n    this.headers = headers;\n    this.data = data;\n  }\n\n  toRackResponse() {\n    let { headers } = this;\n    if (!headers.hasOwnProperty('Content-Type')) {\n      headers['Content-Type'] = 'application/json';\n    }\n\n    return [this.code, this.headers, this.data];\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handler.js":"import Ember from 'ember';\nimport { MirageError } from 'ember-cli-mirage/assert';\nimport Response from './response';\nimport FunctionHandler from './route-handlers/function';\nimport ObjectHandler from './route-handlers/object';\nimport GetShorthandHandler from './route-handlers/shorthands/get';\nimport PostShorthandHandler from './route-handlers/shorthands/post';\nimport PutShorthandHandler from './route-handlers/shorthands/put';\nimport DeleteShorthandHandler from './route-handlers/shorthands/delete';\nimport HeadShorthandHandler from './route-handlers/shorthands/head';\n\nconst { RSVP: { Promise }, isBlank, typeOf } = Ember;\n\nfunction isNotBlankResponse(response) {\n  return response\n    && !(typeOf(response) === 'object' && Object.keys(response).length === 0)\n    && (Array.isArray(response) || !isBlank(response));\n}\n\nconst DEFAULT_CODES = { get: 200, put: 204, post: 201, 'delete': 204 };\n\nfunction createHandler({ verb, schema, serializerOrRegistry, path, rawHandler, options }) {\n  let handler;\n  let args = [schema, serializerOrRegistry, rawHandler, path, options];\n  let type = typeOf(rawHandler);\n\n  if (type === 'function') {\n    handler = new FunctionHandler(...args);\n  } else if (type === 'object') {\n    handler = new ObjectHandler(...args);\n  } else if (verb === 'get') {\n    handler = new GetShorthandHandler(...args);\n  } else if (verb === 'post') {\n    handler = new PostShorthandHandler(...args);\n  } else if (verb === 'put' || verb === 'patch') {\n    handler = new PutShorthandHandler(...args);\n  } else if (verb === 'delete') {\n    handler = new DeleteShorthandHandler(...args);\n  } else if (verb === 'head') {\n    handler = new HeadShorthandHandler(...args);\n  }\n  return handler;\n}\n\nexport default class RouteHandler {\n\n  constructor({ schema, verb, rawHandler, customizedCode, options, path, serializerOrRegistry }) {\n    this.verb = verb;\n    this.customizedCode = customizedCode;\n    this.serializerOrRegistry = serializerOrRegistry;\n    this.handler = createHandler({ verb, schema, path, serializerOrRegistry, rawHandler, options });\n  }\n\n  handle(request) {\n    return new Promise(resolve => {\n      this._getMirageResponseForRequest(request).then(mirageResponse => {\n        this.serialize(mirageResponse, request).then(serializedMirageResponse => {\n          resolve(serializedMirageResponse.toRackResponse());\n        });\n      });\n    });\n  }\n\n  _getMirageResponseForRequest(request) {\n    let result;\n    try {\n      /*\n       We need to do this for the #serialize convenience method. Probably is\n       a better way.\n     */\n      if (this.handler instanceof FunctionHandler) {\n        this.handler.setRequest(request);\n      }\n\n      result = this.handler.handle(request);\n    } catch(e) {\n      if (e instanceof MirageError) {\n        throw e;\n      } else {\n        let message = (typeOf(e) === 'string') ? e : e.message;\n        throw new MirageError(`Your handler for the url ${request.url} threw an error: ${message}`);\n      }\n    }\n\n    return this._toMirageResponse(result);\n  }\n\n  _toMirageResponse(result) {\n    let mirageResponse;\n\n    return new Promise(resolve => {\n      Promise.resolve(result).then(response => {\n        if (response instanceof Response) {\n          mirageResponse = result;\n        } else {\n          let code = this._getCodeForResponse(response);\n          mirageResponse = new Response(code, {}, response);\n        }\n        resolve(mirageResponse);\n      });\n\n    });\n  }\n\n  _getCodeForResponse(response) {\n    let code;\n    if (this.customizedCode) {\n      code = this.customizedCode;\n    } else {\n      code = DEFAULT_CODES[this.verb];\n      if (code === 204 && isNotBlankResponse(response)) {\n        code = 200;\n      }\n    }\n    return code;\n  }\n\n  serialize(mirageResponsePromise, request) {\n    return new Promise(resolve => {\n      Promise.resolve(mirageResponsePromise).then(mirageResponse => {\n        mirageResponse.data = this.serializerOrRegistry.serialize(mirageResponse.data, request);\n        resolve(mirageResponse);\n      });\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/serializer.js":"import Model from './orm/model';\nimport Collection from './orm/collection';\nimport extend from './utils/extend';\nimport { singularize, pluralize, camelize } from './utils/inflector';\n\nimport _isFunction from 'lodash/isFunction';\nimport _isArray from 'lodash/isArray';\nimport _isEmpty from 'lodash/isEmpty';\nimport _includes from 'lodash/includes';\nimport _assign from 'lodash/assign';\nimport _get from 'lodash/get';\nimport _ from 'lodash';\n\nclass Serializer {\n\n  constructor(registry, type, request) {\n    this.registry = registry;\n    this.type = type;\n    this.request = request;\n  }\n\n  /**\n   * Override this method to implement your own custom\n   * serialize function. `primaryResource` is whatever was returned\n   * from your route handler, and request is the Pretender\n   * request object. Returns a plain JavaScript object or\n   * array, which Mirage uses as the response data to your\n   * Ember app’s XHR request. You can also override this method,\n   * call super, and manipulate the data before Mirage responds\n   * with it. This is a great place to add metadata, or for\n   * one-off operations that don’t fit neatly into any of\n   * Mirage’s other abstractions.\n   * @method serialize\n   * @param response\n   * @param request\n   * @public\n   */\n  serialize(primaryResource /* , request */) {\n    return this.buildPayload(primaryResource);\n  }\n\n  buildPayload(primaryResource, toInclude, didSerialize, json) {\n    if (!primaryResource && _isEmpty(toInclude)) {\n      return json;\n\n    } else if (primaryResource) {\n      let [resourceHash, newIncludes] = this.getHashForPrimaryResource(primaryResource);\n      let newDidSerialize = (this.isCollection(primaryResource) ? primaryResource.models : [primaryResource]);\n\n      return this.buildPayload(undefined, newIncludes, newDidSerialize, resourceHash);\n\n    } else {\n      let nextIncludedResource = toInclude.shift();\n      let [resourceHash, newIncludes] = this.getHashForIncludedResource(nextIncludedResource);\n\n      let newToInclude = newIncludes\n        .filter((resource) => {\n          return !_includes(didSerialize.map((m) => m.toString()), resource.toString());\n        })\n        .concat(toInclude);\n      let newDidSerialize = (this.isCollection(nextIncludedResource) ? nextIncludedResource.models : [nextIncludedResource])\n        .concat(didSerialize);\n      let newJson = this.mergePayloads(json, resourceHash);\n\n      return this.buildPayload(undefined, newToInclude, newDidSerialize, newJson);\n    }\n  }\n\n  getHashForPrimaryResource(resource) {\n    let [hash, addToIncludes] = this.getHashForResource(resource);\n    let hashWithRoot;\n\n    if (this.root) {\n      let serializer = this.serializerFor(resource.modelName);\n      let rootKey = serializer.keyForResource(resource);\n      hashWithRoot = { [rootKey]: hash };\n    } else {\n      hashWithRoot = hash;\n    }\n\n    return [hashWithRoot, addToIncludes];\n  }\n\n  getHashForIncludedResource(resource) {\n    let serializer = this.serializerFor(resource.modelName);\n    let [hash, addToIncludes] = serializer.getHashForResource(resource);\n\n    // Included resources always have a root, and are always pushed to an array.\n    let rootKey = serializer.keyForRelationship(resource.modelName);\n    let hashWithRoot = _isArray(hash) ? { [rootKey]: hash } : { [rootKey]: [hash] };\n\n    return [hashWithRoot, addToIncludes];\n  }\n\n  getHashForResource(resource, removeForeignKeys = false, didSerialize = {}, lookupSerializer = false) {\n    let hash;\n    let serializer = lookupSerializer ? this.serializerFor(resource.modelName) : this; // this is used for embedded responses\n\n    if (this.isModel(resource)) {\n      hash = serializer._hashForModel(resource, removeForeignKeys, didSerialize);\n    } else {\n      hash = resource.models.map((m) => serializer._hashForModel(m, removeForeignKeys, didSerialize));\n    }\n\n    if (this.embed) {\n      return [hash];\n\n    } else {\n      let addToIncludes = _(serializer.getKeysForIncluded())\n        .map((key) => {\n          if (this.isCollection(resource)) {\n            return resource.models.map((m) => m[key]);\n          } else {\n            return resource[key];\n          }\n        })\n        .flatten()\n        .compact()\n        .uniqBy(m => m.toString())\n        .value();\n\n      return [hash, addToIncludes];\n    }\n  }\n\n  /*\n    Merges new resource hash into json. If json already has root key,\n    pushes value of resourceHash onto that key.\n\n    For example,\n\n        json = {\n          post: { id: 1, title: 'Lorem Ipsum', comment_ids: [1, 3] },\n          comments: [\n            { id: 1, text: 'foo' }\n          ]\n        };\n\n        resourceHash = {\n          comments: [\n            { id: 2, text: 'bar' }\n          ]\n        };\n\n    would yield\n\n        {\n          post: { id: 1, title: 'Lorem Ipsum', comment_ids: [1, 3] },\n          comments: [\n            { id: 1, text: 'foo' },\n            { id: 2, text: 'bar' }\n          ]\n        };\n\n  */\n  mergePayloads(json, resourceHash) {\n    let newJson;\n    let [resourceHashKey] = Object.keys(resourceHash);\n\n    if (json[resourceHashKey]) {\n      newJson = json;\n      newJson[resourceHashKey] = json[resourceHashKey].concat(resourceHash[resourceHashKey]);\n    } else {\n      newJson = _assign(json, resourceHash);\n    }\n\n    return newJson;\n  }\n\n  keyForResource(resource) {\n    let { modelName } = resource;\n    return this.isModel(resource) ? this.keyForModel(modelName) : this.keyForCollection(modelName);\n  }\n\n  /**\n   * Used to define a custom key when serializing a\n   * primary model of modelName `modelName`.\n   * @method keyForModel\n   * @param modelName\n   * @public\n   */\n  keyForModel(modelName) {\n    return camelize(modelName);\n  }\n\n  /**\n   * Used to customize the key when serializing a primary\n   * collection. By default this pluralizes the return\n   * value of `keyForModel`.\n   * @method keyForCollection\n   * @param modelName\n   * @public\n   */\n  keyForCollection(modelName) {\n    return pluralize(this.keyForModel(modelName));\n  }\n\n  _hashForModel(model, removeForeignKeys, didSerialize = {}) {\n    let attrs = this._attrsForModel(model);\n\n    if (removeForeignKeys) {\n      model.fks.forEach((fk) => {\n        delete attrs[fk];\n      });\n    }\n\n    if (this.embed) {\n      let newDidSerialize = _assign({}, didSerialize);\n      newDidSerialize[model.modelName] = newDidSerialize[model.modelName] || {};\n      newDidSerialize[model.modelName][model.id] = true;\n\n      this.getKeysForIncluded().forEach((key) => {\n        let associatedResource = model[key];\n        if (!_get(newDidSerialize, `${associatedResource.modelName}.${associatedResource.id}`)) {\n          let [ associatedResourceHash ] = this.getHashForResource(associatedResource, true, newDidSerialize, true);\n          let formattedKey = this.keyForEmbeddedRelationship(key);\n          attrs[formattedKey] = associatedResourceHash;\n\n          if (this.isModel(associatedResource)) {\n            let fk = `${camelize(key)}Id`;\n            delete attrs[fk];\n          }\n        }\n      });\n\n      return attrs;\n    } else {\n      return this._maybeAddAssociationIds(model, attrs);\n    }\n  }\n\n  /**\n   * @method _attrsForModel\n   * @param model\n   * @private\n   */\n  _attrsForModel(model) {\n    let attrs = {};\n\n    if (this.attrs) {\n      attrs = this.attrs.reduce((memo, attr) => {\n        memo[attr] = model[attr];\n        return memo;\n      }, {});\n    } else {\n      attrs = _assign(attrs, model.attrs);\n    }\n\n    // Remove fks\n    model.fks.forEach(key => delete attrs[key]);\n\n    return this._formatAttributeKeys(attrs);\n  }\n\n  /**\n   * @method _maybeAddAssociationIds\n   * @param model\n   * @param attrs\n   * @private\n   */\n  _maybeAddAssociationIds(model, attrs) {\n    let newHash = _assign({}, attrs);\n\n    if (this.serializeIds === 'always') {\n      model.associationKeys.forEach((key) => {\n        let association = model[key];\n        if (this.isCollection(association)) {\n          let formattedKey = this.keyForRelationshipIds(key);\n          newHash[formattedKey] = model[key].models.map((m) => m.id);\n        } else if (association) {\n          let formattedKey = this.keyForForeignKey(key);\n          newHash[formattedKey] = model[key].id;\n        }\n      });\n    } else if (this.serializeIds === 'included') {\n      this.getKeysForIncluded().forEach((key) => {\n        let association = model[key];\n        if (this.isCollection(association)) {\n          let formattedKey = this.keyForRelationshipIds(key);\n          newHash[formattedKey] = model[key].models.map((m) => m.id);\n        } else if (association) {\n          let formattedKey = this.keyForForeignKey(key);\n          newHash[formattedKey] = model[key].id;\n        }\n      });\n    }\n\n    return newHash;\n  }\n\n  /**\n   * Used to customize how a model’s attribute is\n   * formatted in your JSON payload.\n   * @method keyForAttribute\n   * @param attr\n   * @public\n   */\n  keyForAttribute(attr) {\n    return attr;\n  }\n\n  /**\n   * Use this hook to format the key for collections\n   * related to this model.\n   *\n   * For example, if you're serializing an author that\n   * side loads many `blogPosts`, you would get `blogPost`\n   * as an argument, and whatever you return would\n   * end up as the collection key in your JSON:\n   *\n   * keyForRelationship(type) {\n   *   return dasherize(type);\n   * }\n   *\n   * {\n   *   author: {...},\n   *   'blog-posts': [...]\n   * }\n   * @method keyForRelationship\n   * @param modelName\n   * @public\n   */\n  keyForRelationship(modelName) {\n    return camelize(pluralize(modelName));\n  }\n\n  /**\n   * @method keyForEmbeddedRelationship\n   * @param attributeName\n   * @public\n   */\n  keyForEmbeddedRelationship(attributeName) {\n    return camelize(attributeName);\n  }\n\n  /**\n   * Use this hook to format the key for relationship ids\n   * in this model's JSON representation.\n   *\n   * For example, if you're serializing an author that\n   * side loads many `blogPosts`, you would get `blogPost`\n   * as an argument, and whatever you return would\n   * end up as part of the `author` JSON:\n   *\n   * keyForRelationshipIds(type) {\n   *   return dasherize(type) + '-ids';\n   * }\n   *\n   * {\n   *   author: {\n   *     ...,\n   *     'blog-post-ids': [1, 2, 3]\n   *   },\n   *   'blog-posts': [...]\n   * }\n   * @method keyForRelationshipIds\n   * @param modelName\n   * @public\n   */\n  keyForRelationshipIds(relationshipName) {\n    return `${singularize(camelize(relationshipName))}Ids`;\n  }\n\n  keyForForeignKey(relationshipName) {\n    return `${camelize(relationshipName)}Id`;\n  }\n\n  /**\n   * This method is used by the POST and PUT shorthands. These shorthands\n   * expect a valid JSON:API document as part of the request, so that\n   * they know how to create or update the appropriate resouce. The normalize\n   * method allows you to transform your request body into a JSON:API\n   * document, which lets you take advantage of the shorthands when you\n   * otherwise may not be able to.\n   *\n   * Note that this method is a noop if you’re using JSON:API already,\n   * since request payloads sent along with POST and PUT requests will\n   * already be in the correct format.\n   * @method normalize\n   * @param json\n   * @public\n   */\n  normalize(json) {\n    return json;\n  }\n\n  /**\n   * @method isModel\n   * @param object\n   * @return {Boolean}\n   * @public\n   */\n  isModel(object) {\n    return object instanceof Model;\n  }\n\n  /**\n   * @method isCollection\n   * @param object\n   * @return {Boolean}\n   * @public\n   */\n  isCollection(object) {\n    return object instanceof Collection;\n  }\n\n  /**\n   * @method isModelOrCollection\n   * @param object\n   * @return {Boolean}\n   * @public\n   */\n  isModelOrCollection(object) {\n    return this.isModel(object) || this.isCollection(object);\n  }\n\n  /**\n   * @method serializerFor\n   * @param type\n   * @public\n   */\n  serializerFor(type) {\n    return this.registry.serializerFor(type);\n  }\n\n  getKeysForIncluded() {\n    return _isFunction(this.include) ? this.include(this.request) : this.include;\n  }\n\n  /**\n   * @method _formatAttributeKeys\n   * @param attrs\n   * @private\n   */\n  _formatAttributeKeys(attrs) {\n    let formattedAttrs = {};\n\n    for (let key in attrs) {\n      let formattedKey = this.keyForAttribute(key);\n      formattedAttrs[formattedKey] = attrs[key];\n    }\n\n    return formattedAttrs;\n  }\n}\n\n// Defaults\nSerializer.prototype.include = [];\nSerializer.prototype.root = true;\nSerializer.prototype.embed = false;\nSerializer.prototype.serializeIds = 'included'; // can be 'included', 'always', or 'never'\n\nSerializer.extend = extend;\n\nexport default Serializer;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/serializer-registry.js":"import Model from 'ember-cli-mirage/orm/model';\nimport Collection from 'ember-cli-mirage/orm/collection';\nimport Serializer from 'ember-cli-mirage/serializer';\nimport JsonApiSerializer from 'ember-cli-mirage/serializers/json-api-serializer';\nimport { pluralize, camelize } from './utils/inflector';\nimport assert from './assert';\n\nimport _assign from 'lodash/assign';\n\nexport default class SerializerRegistry {\n\n  constructor(schema, serializerMap = {}) {\n    this.schema = schema;\n    this._serializerMap = serializerMap;\n  }\n\n  normalize(payload, modelName) {\n    return this.serializerFor(modelName).normalize(payload);\n  }\n\n  serialize(response, request) {\n    this.request = request;\n\n    if (this._isModelOrCollection(response)) {\n      let serializer = this.serializerFor(response.modelName);\n\n      return serializer.serialize(response, request);\n    } else if (Array.isArray(response) && response.filter(this._isCollection).length) {\n      return response.reduce((json, collection) => {\n        let serializer = this.serializerFor(collection.modelName);\n\n        if (serializer.embed) {\n          json[pluralize(collection.modelName)] = serializer.serialize(collection, request);\n        } else {\n          json = _assign(json, serializer.serialize(collection, request));\n        }\n\n        return json;\n      }, {});\n\n    } else {\n      return response;\n    }\n  }\n\n  serializerFor(type, { explicit = false } = {}) {\n    let SerializerForResponse = this._serializerMap && (this._serializerMap[camelize(type)]);\n\n    if (explicit) {\n      assert(!!SerializerForResponse, `You passed in ${type} as an explicit serializer type but that serializer doesn't exist. Try running \\`ember g mirage-serializer ${type}\\`.`);\n    } else {\n      SerializerForResponse = SerializerForResponse || this._serializerMap.application || Serializer;\n\n      assert(\n        !SerializerForResponse\n        || (SerializerForResponse.prototype.embed)\n        || (SerializerForResponse.prototype.root)\n        || (new SerializerForResponse() instanceof JsonApiSerializer),\n        'You cannot have a serializer that sideloads (embed: false) and disables the root (root: false).'\n      );\n    }\n\n    return new SerializerForResponse(this, type, this.request);\n  }\n\n  _isModel(object) {\n    return object instanceof Model;\n  }\n\n  _isCollection(object) {\n    return object instanceof Collection;\n  }\n\n  _isModelOrCollection(object) {\n    return this._isModel(object) || this._isCollection(object);\n  }\n\n  registerSerializers(newSerializerMaps) {\n    let currentSerializerMap = this._serializerMap || {};\n    this._serializerMap = _assign(\n      currentSerializerMap,\n      newSerializerMaps\n    );\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/server.js":"/* eslint no-console: 0 */\n\nimport { pluralize, camelize } from './utils/inflector';\nimport { toCollectionName } from 'ember-cli-mirage/utils/normalize-name';\nimport Ember from 'ember';\nimport isAssociation from 'ember-cli-mirage/utils/is-association';\nimport Pretender from 'pretender';\nimport Db from './db';\nimport Schema from './orm/schema';\nimport assert from './assert';\nimport SerializerRegistry from './serializer-registry';\nimport RouteHandler from './route-handler';\n\nimport _pick from 'lodash/pick';\nimport _assign from 'lodash/assign';\nimport _find from 'lodash/find';\nimport _isPlainObject from 'lodash/isPlainObject';\nimport _isInteger from 'lodash/isInteger';\n\nconst { RSVP: { Promise } } = Ember;\n\n/**\n * Creates a new Pretender instance.\n *\n * @method createPretender\n * @param {Server} server\n * @return {Object} A new Pretender instance.\n * @public\n */\nfunction createPretender(server) {\n  return new Pretender(function() {\n    this.passthroughRequest = function(verb, path, request) {\n      if (server.shouldLog()) {\n        console.log(`Passthrough request: ${verb.toUpperCase()} ${request.url}`);\n      }\n    };\n\n    this.handledRequest = function(verb, path, request) {\n      if (server.shouldLog()) {\n        console.log(`Mirage: [${request.status}] ${verb.toUpperCase()} ${request.url}`);\n        let { responseText } = request;\n        let loggedResponse;\n\n        try {\n          loggedResponse = JSON.parse(responseText);\n        } catch(e) {\n          loggedResponse = responseText;\n        }\n\n        console.log(loggedResponse);\n      }\n    };\n\n    this.unhandledRequest = function(verb, path) {\n      path = decodeURI(path);\n      assert(\n        `Your Ember app tried to ${verb} '${path}',\n         but there was no route defined to handle this request.\n         Define a route that matches this path in your\n         mirage/config.js file. Did you forget to add your namespace?`\n      );\n    };\n  });\n}\n\nconst defaultRouteOptions = {\n  coalesce: false,\n  timing: undefined\n};\n\nconst defaultPassthroughs = [\n  'http://localhost:0/chromecheckurl', // mobile chrome\n  'http://localhost:30820/socket.io' // electron\n];\nexport { defaultPassthroughs };\n\n/**\n * Determine if the object contains a valid option.\n *\n * @method isOption\n * @param {Object} option An object with one option value pair.\n * @return {Boolean} True if option is a valid option, false otherwise.\n * @private\n */\nfunction isOption(option) {\n  if (!option || typeof option !== 'object') {\n    return false;\n  }\n\n  let allOptions = Object.keys(defaultRouteOptions);\n  let optionKeys = Object.keys(option);\n  for (let i = 0; i < optionKeys.length; i++) {\n    let key = optionKeys[i];\n    if (allOptions.indexOf(key) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Extract arguments for a route.\n *\n * @method extractRouteArguments\n * @param {Array} args Of the form [options], [object, code], [function, code]\n * [shorthand, options], [shorthand, code, options]\n * @return {Array} [handler (i.e. the function, object or shorthand), code,\n * options].\n * @private\n */\nfunction extractRouteArguments(args) {\n  let [ lastArg ] = args.splice(-1);\n  if (isOption(lastArg)) {\n    lastArg = _assign({}, defaultRouteOptions, lastArg);\n  } else {\n    args.push(lastArg);\n    lastArg = defaultRouteOptions;\n  }\n  let t = 2 - args.length;\n  while (t-- > 0) {\n    args.push(undefined);\n  }\n  args.push(lastArg);\n  return args;\n}\n\n/**\n *\n *\n * @class Server\n * @public\n */\nexport default class Server {\n\n  /**\n   * Build the new server object.\n   *\n   * @constructor\n   * @public\n   */\n  constructor(options = {}) {\n    this.config(options);\n  }\n\n  config(config = {}) {\n    let didOverrideConfig = (config.environment && (this.environment && (this.environment !== config.environment)));\n    assert(!didOverrideConfig,\n    'You cannot modify Mirage\\'s environment once the server is created');\n    this.environment = config.environment || 'development';\n\n    this.options = config;\n\n    this.timing = this.timing || config.timing || 400;\n    this.namespace = this.namespace || config.namespace || '';\n    this.urlPrefix = this.urlPrefix || config.urlPrefix || '';\n\n    this._defineRouteHandlerHelpers();\n\n    this.db = this.db || new Db();\n    if (this.schema) {\n      this.schema.registerModels(config.models);\n      this.serializerOrRegistry.registerSerializers(config.serializers || {});\n    } else {\n      this.schema = new Schema(this.db, config.models);\n      this.serializerOrRegistry = new SerializerRegistry(this.schema, config.serializers);\n    }\n\n    let hasFactories = this._hasModulesOfType(config, 'factories');\n    let hasDefaultScenario = config.scenarios && config.scenarios.hasOwnProperty('default');\n\n    this.pretender = this.pretender || createPretender(this);\n\n    if (config.baseConfig) {\n      this.loadConfig(config.baseConfig);\n    }\n\n    if (this.isTest()) {\n      if (config.testConfig) {\n        this.loadConfig(config.testConfig);\n      }\n\n      window.server = this; // TODO: Better way to inject server into test env\n    }\n\n    if (this.isTest() && hasFactories) {\n      this.loadFactories(config.factories);\n    } else if (!this.isTest() && hasDefaultScenario) {\n      this.loadFactories(config.factories);\n      config.scenarios.default(this);\n    } else {\n      this.loadFixtures();\n    }\n\n    if (config.useDefaultPassthroughs) {\n      this._configureDefaultPassthroughs();\n    }\n  }\n\n  /**\n   * Determines if the current environment is the testing environment.\n   *\n   * @method isTest\n   * @return {Boolean} True if the environment is 'test', false otherwise.\n   * @public\n   */\n  isTest() {\n    return this.environment === 'test';\n  }\n\n  /**\n   * Determines if the server should log.\n   *\n   * @method shouldLog\n   * @return The value of this.logging if defined, or false if in the testing environment,\n   * true otherwise.\n   * @public\n   */\n  shouldLog() {\n    return typeof this.logging !== 'undefined' ? this.logging : !this.isTest();\n  }\n\n  /**\n   * Load the configuration given, setting timing to 0 if in the test\n   * environment.\n   *\n   * @method loadConfig\n   * @param {Object} config The configuration to load.\n   * @public\n   */\n  loadConfig(config) {\n    config.call(this);\n    this.timing = this.isTest() ? 0 : (this.timing || 0);\n  }\n\n  /**\n   * Whitelist requests to the specified paths and allow them to pass through\n   * your Mirage server to the actual network layer.\n   *\n   * @method passthrough\n   * @param {String} [...paths] Any numer of paths to whitelist\n   * @param {Array} options Unused\n   * @public\n   */\n  passthrough(...paths) {\n    let verbs = ['get', 'post', 'put', 'delete', 'patch'];\n    let lastArg = paths[paths.length - 1];\n\n    if (paths.length === 0) {\n      // paths = ['http://localhost:7357'];\n      paths = ['/**', '/'];\n    } else if (Array.isArray(lastArg)) {\n      verbs = paths.pop();\n    }\n\n    verbs.forEach((verb) => {\n      paths.forEach((path) => {\n        let fullPath = this._getFullPath(path);\n        this.pretender[verb](fullPath, this.pretender.passthrough);\n      });\n    });\n  }\n\n  /**\n   * Load the all or only the specified fixtures into Mirage's database.\n   *\n   * @method loadFixtures\n   * @param {String} [...args] The name of the fixture to load.\n   * @public\n   */\n  loadFixtures(...args) {\n    let { fixtures } = this.options;\n    if (args.length) {\n      let camelizedArgs = args.map(camelize);\n      fixtures = _pick(fixtures, ...camelizedArgs);\n    }\n\n    this.db.loadData(fixtures);\n  }\n\n  /*\n    Factory methods\n  */\n\n  /**\n   * Load factories into Mirage's database.\n   *\n   * @method loadFactories\n   * @param {Object} factoryMap\n   * @public\n   */\n  loadFactories(factoryMap = {}) {\n    // Store a reference to the factories\n    let currentFactoryMap = this._factoryMap || {};\n    this._factoryMap = _assign(currentFactoryMap, factoryMap);\n\n    // Create a collection for each factory\n    Object.keys(factoryMap).forEach((type) => {\n      let collectionName = toCollectionName(type);\n      this.db.createCollection(collectionName);\n    });\n  }\n\n  /**\n   * Get the factory for a given type.\n   *\n   * @method factoryFor\n   * @param {String} type\n   * @private\n   */\n  factoryFor(type) {\n    let camelizedType = camelize(type);\n\n    if (this._factoryMap && this._factoryMap[camelizedType]) {\n      return this._factoryMap[camelizedType];\n    }\n  }\n\n  build(type, ...traitsAndOverrides) {\n    let traits = traitsAndOverrides.filter((arg) => arg && typeof arg === 'string');\n    let overrides = _find(traitsAndOverrides, (arg) => _isPlainObject(arg));\n    let camelizedType = camelize(type);\n\n    // Store sequence for factory type as instance variable\n    this.factorySequences = this.factorySequences || {};\n    this.factorySequences[camelizedType] = this.factorySequences[camelizedType] + 1 || 0;\n\n    let OriginalFactory = this.factoryFor(type);\n    if (OriginalFactory) {\n      OriginalFactory = OriginalFactory.extend({});\n      let attrs = OriginalFactory.attrs || {};\n      this._validateTraits(traits, OriginalFactory, type);\n      let mergedExtensions = this._mergeExtensions(attrs, traits, overrides);\n      this._mapAssociationsFromAttributes(type, attrs);\n      this._mapAssociationsFromAttributes(type, mergedExtensions);\n\n      let Factory = OriginalFactory.extend(mergedExtensions);\n      let factory = new Factory();\n\n      let sequence = this.factorySequences[camelizedType];\n      return factory.build(sequence);\n    } else {\n      return overrides;\n    }\n  }\n\n  buildList(type, amount, ...traitsAndOverrides) {\n    assert(_isInteger(amount), `second argument has to be an integer, you passed: ${typeof amount}`);\n\n    let list = [];\n\n    for (let i = 0; i < amount; i++) {\n      list.push(this.build(type, ...traitsAndOverrides));\n    }\n\n    return list;\n  }\n\n  create(type, ...options) {\n    // When there is a Model defined, we should return an instance\n    // of it instead of returning the bare attributes.\n    let traits = options.filter((arg) => arg && typeof arg === 'string');\n    let overrides = _find(options, (arg) => _isPlainObject(arg));\n    let collectionFromCreateList = _find(options, (arg) => arg && Array.isArray(arg));\n\n    let attrs = this.build(type, ...traits, overrides);\n    let modelOrRecord;\n\n    if (this.schema && this.schema[toCollectionName(type)]) {\n      let modelClass = this.schema[toCollectionName(type)];\n\n      modelOrRecord = modelClass.create(attrs);\n\n    } else {\n      let collection, collectionName;\n\n      if (collectionFromCreateList) {\n        collection = collectionFromCreateList;\n      } else {\n        collectionName = this.schema ? toCollectionName(type) : pluralize(type);\n        collection = this.db[collectionName];\n      }\n\n      assert(collection, `You called server.create(${type}) but no model or factory was found. Try \\`ember g mirage-model ${type}\\`.`);\n      modelOrRecord = collection.insert(attrs);\n    }\n\n    let OriginalFactory = this.factoryFor(type);\n    if (OriginalFactory) {\n      OriginalFactory.extractAfterCreateCallbacks({ traits }).forEach((afterCreate) => {\n        afterCreate(modelOrRecord, this);\n      });\n    }\n\n    return modelOrRecord;\n  }\n\n  createList(type, amount, ...traitsAndOverrides) {\n    assert(_isInteger(amount), `second argument has to be an integer, you passed: ${typeof amount}`);\n\n    let list = [];\n    let collectionName = this.schema ? toCollectionName(type) : pluralize(type);\n    let collection = this.db[collectionName];\n\n    for (let i = 0; i < amount; i++) {\n      list.push(this.create(type, ...traitsAndOverrides, collection));\n    }\n\n    return list;\n  }\n\n  shutdown() {\n    this.pretender.shutdown();\n    if (this.environment === 'test') {\n      window.server = undefined;\n    }\n  }\n\n  resource(resourceName, { only, except } = {}) {\n    only = only || [];\n    except = except || [];\n\n    if (only.length > 0 && except.length > 0) {\n      throw 'cannot use both :only and :except options';\n    }\n\n    let actionsMethodsAndsPathsMappings = {\n      index: { methods: ['get'], path: `/${resourceName}` },\n      show: { methods: ['get'], path: `/${resourceName}/:id` },\n      create: { methods: ['post'], path: `/${resourceName}` },\n      update: { methods: ['put', 'patch'], path: `/${resourceName}/:id` },\n      delete: { methods: ['del'], path: `/${resourceName}/:id` }\n    };\n\n    let allActions = Object.keys(actionsMethodsAndsPathsMappings);\n    let actions = only.length > 0 && only\n                  || except.length > 0 && allActions.filter((action) => (except.indexOf(action) === -1))\n                  || allActions;\n\n    actions.forEach((action) => {\n      let methodsWithPath = actionsMethodsAndsPathsMappings[action];\n\n      methodsWithPath.methods.forEach((method) => this[method](methodsWithPath.path));\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _defineRouteHandlerHelpers() {\n    [['get'], ['post'], ['put'], ['delete', 'del'], ['patch'], ['head']].forEach(([verb, alias]) => {\n      this[verb] = (path, ...args) => {\n        let [ rawHandler, customizedCode, options ] = extractRouteArguments(args);\n        this._registerRouteHandler(verb, path, rawHandler, customizedCode, options);\n      };\n\n      if (alias) {\n        this[alias] = this[verb];\n      }\n    });\n  }\n\n  _serialize(body) {\n    if (typeof body === 'string') {\n      return body;\n    } else if (body) {\n      return JSON.stringify(body);\n    } else {\n      return '{\"error\": \"not found\"}';\n    }\n  }\n\n  _registerRouteHandler(verb, path, rawHandler, customizedCode, options) {\n\n    let routeHandler = new RouteHandler({\n      schema: this.schema,\n      verb, rawHandler, customizedCode, options, path,\n      serializerOrRegistry: this.serializerOrRegistry\n    });\n\n    let fullPath = this._getFullPath(path);\n    let timing = options.timing !== undefined ? options.timing : (() => this.timing);\n\n    this.pretender[verb](\n      fullPath,\n      (request) => {\n        return new Promise(resolve => {\n          Promise.resolve(routeHandler.handle(request)).then(mirageResponse => {\n            let [ code, headers, response ] = mirageResponse;\n            resolve([ code, headers, this._serialize(response) ]);\n          });\n        });\n      },\n      timing\n    );\n  }\n\n  /**\n   *\n   * @private\n   */\n  _hasModulesOfType(modules, type) {\n    let modulesOfType = modules[type];\n    return modulesOfType ? Object.keys(modulesOfType).length > 0 : false;\n  }\n\n  /**\n   * Builds a full path for Pretender to monitor based on the `path` and\n   * configured options (`urlPrefix` and `namespace`).\n   *\n   * @private\n   */\n  _getFullPath(path) {\n    path = path[0] === '/' ? path.slice(1) : path;\n    let fullPath = '';\n    let urlPrefix = this.urlPrefix ? this.urlPrefix.trim() : '';\n    let namespace = '';\n\n    // if there is a urlPrefix and a namespace\n    if (this.urlPrefix && this.namespace) {\n      if (this.namespace[0] === '/' && this.namespace[this.namespace.length - 1] === '/') {\n        namespace = this.namespace.substring(0, this.namespace.length - 1).substring(1);\n      }\n\n      if (this.namespace[0] === '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = this.namespace.substring(1);\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] === '/') {\n        namespace = this.namespace.substring(0, this.namespace.length - 1);\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = this.namespace;\n      }\n    }\n\n    // if there is a namespace and no urlPrefix\n    if (this.namespace && !this.urlPrefix) {\n      if (this.namespace[0] === '/' && this.namespace[this.namespace.length - 1] === '/') {\n        namespace = this.namespace.substring(0, this.namespace.length - 1);\n      }\n\n      if (this.namespace[0] === '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = this.namespace;\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] === '/') {\n        let namespaceSub = this.namespace.substring(0, this.namespace.length - 1);\n        namespace = `/${namespaceSub}`;\n      }\n\n      if (this.namespace[0] !== '/' &&  this.namespace[this.namespace.length - 1] !== '/') {\n        namespace = `/${this.namespace}`;\n      }\n    }\n\n    // if no namespace\n    if (!this.namespace) {\n      namespace = '';\n    }\n\n    // check to see if path is a FQDN. if so, ignore any urlPrefix/namespace that was set\n    if (/^https?:\\/\\//.test(path)) {\n      fullPath += path;\n    } else {\n      // otherwise, if there is a urlPrefix, use that as the beginning of the path\n      if (urlPrefix.length) {\n        fullPath += (urlPrefix[urlPrefix.length - 1] === '/') ? urlPrefix : `${urlPrefix}/`;\n      }\n\n      // add the namespace to the path\n      fullPath += namespace;\n\n      // add a trailing slash to the path if it doesn't already contain one\n      if (fullPath[fullPath.length - 1] !== '/') {\n        fullPath += '/';\n      }\n\n      // finally add the configured path\n      fullPath += path;\n\n      // if we're making a same-origin request, ensure a / is prepended and\n      // dedup any double slashes\n      if (!/^https?:\\/\\//.test(fullPath)) {\n        fullPath = `/${fullPath}`;\n        fullPath = fullPath.replace(/\\/+/g, '/');\n      }\n    }\n\n    return fullPath;\n  }\n\n  /**\n   *\n   * @private\n   */\n  _configureDefaultPassthroughs() {\n    defaultPassthroughs.forEach((passthroughUrl) => {\n      this.passthrough(passthroughUrl);\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _validateTraits(traits, factory, type) {\n    traits.forEach((traitName) => {\n      if (!factory.isTrait(traitName)) {\n        throw new Error(`'${traitName}' trait is not registered in '${type}' factory`);\n      }\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _mergeExtensions(attrs, traits, overrides) {\n    let allExtensions = traits.map((traitName) => {\n      return attrs[traitName].extension;\n    });\n    allExtensions.push(overrides || {});\n    return allExtensions.reduce((accum, extension) => {\n      return _assign(accum, extension);\n    }, {});\n  }\n\n  /**\n   *\n   * @private\n   */\n  _mapAssociationsFromAttributes(modelType, attributes) {\n    Object.keys(attributes || {}).filter((attr) => {\n      return isAssociation(attributes[attr]);\n    }).forEach((attr) => {\n      let association = attributes[attr];\n      let associationName = this._fetchAssociationNameFromModel(modelType, attr);\n      let foreignKey = `${camelize(attr)}Id`;\n      attributes[foreignKey] = this.create(associationName, ...association.traitsAndOverrides).id;\n      delete attributes[attr];\n    });\n  }\n\n  /**\n   *\n   * @private\n   */\n  _fetchAssociationNameFromModel(modelType, associationAttribute) {\n    let model = this.schema.modelFor(modelType);\n    if (!model) {\n      throw new Error(`Model not registered: ${modelType}`);\n    }\n\n    let association = model.class.findBelongsToAssociation(associationAttribute);\n    if (!association) {\n      throw new Error(`You're using the \\`association\\` factory helper on the '${associationAttribute}' attribute of your ${modelType} factory, but that attribute is not a \\`belongsTo\\` association. Read the Factories docs for more information: http://www.ember-cli-mirage.com/docs/v0.2.x/factories/#factories-and-relationships`);\n    }\n    return camelize(association.modelName);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/trait.js":"let trait = function(extension) {\n  let __isTrait__ = true;\n  return {\n    extension,\n    __isTrait__\n  };\n};\n\nexport default trait;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/config/environment.js":"/* eslint-env node */\n'use strict';\nvar fs = require('fs');\n\nfunction usingProxy() {\n  var usingProxyArg = !!process.argv.filter(function (arg) {\n    return arg.indexOf('--proxy') === 0 || arg.indexOf('-pr') === 0 || arg.indexOf('-pxy') === 0;\n  }).length;\n\n  var hasGeneratedProxies = false;\n  var proxiesDir = process.env.PWD + '/server/proxies';\n  try {\n    fs.lstatSync(proxiesDir);\n    hasGeneratedProxies = true;\n  } catch (e) {}\n\n  return usingProxyArg || hasGeneratedProxies;\n}\n\nmodule.exports = function(environment, appConfig) {\n  appConfig['ember-cli-mirage'] = appConfig['ember-cli-mirage'] || {};\n  appConfig['ember-cli-mirage']['usingProxy'] = usingProxy();\n  appConfig['ember-cli-mirage']['useDefaultPassthroughs'] = true;\n\n  return {};\n};","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/orm/collection.js":"import assert from '../assert';\nimport _invokeMap from 'lodash/invokeMap';\nimport _isEqual from 'lodash/isEqual';\n\n/**\n * An array of models, returned from one of the schema query\n * methods (all, find, where). Knows how to update and destroy its models.\n * @class Collection\n * @constructor\n * @public\n */\nexport default class Collection {\n  constructor(modelName, models = []) {\n    assert(\n      modelName && typeof modelName === 'string',\n      'You must pass a `modelName` into a Collection'\n    );\n\n    this.modelName = modelName;\n    this.models = models;\n  }\n\n  /**\n   * Number of models in the collection.\n   *\n   * @property length\n   * @type Number\n   * @public\n   */\n  get length() {\n    return this.models.length;\n  }\n\n  /**\n   * Updates each model in the collection (persisting immediately to the db).\n   * @method update\n   * @param key\n   * @param val\n   * @return this\n   * @public\n   */\n  update(...args) {\n    _invokeMap(this.models, 'update', ...args);\n\n    return this;\n  }\n\n  /**\n   * Destroys the db record for all models in the collection.\n   * @method destroy\n   * @return this\n   * @public\n   */\n  destroy() {\n    _invokeMap(this.models, 'destroy');\n\n    return this;\n  }\n\n  /**\n   * Saves all models in the collection.\n   * @method save\n   * @return this\n   * @public\n   */\n  save() {\n    _invokeMap(this.models, 'save');\n\n    return this;\n  }\n\n  /**\n   * Reloads each model in the collection.\n   * @method reload\n   * @return this\n   * @public\n   */\n  reload() {\n    _invokeMap(this.models, 'reload');\n\n    return this;\n  }\n\n  /**\n   * Adds a model to this collection\n   *\n   * @method add\n   * @return this\n   * @public\n   */\n  add(model) {\n    this.models.push(model);\n\n    return this;\n  }\n\n  /**\n   * Removes a model to this collection\n   *\n   * @method remove\n   * @return this\n   * @public\n   */\n  remove(model) {\n    let [ match ] = this.models.filter(m => _isEqual(m.attrs, model.attrs));\n    if (match) {\n      let i = this.models.indexOf(match);\n      this.models.splice(i, 1);\n    }\n\n    return this;\n  }\n\n  /**\n   * Checks if the collection includes the model\n   *\n   * @method includes\n   * @return boolean\n   * @public\n   */\n  includes(model) {\n    return this.models.filter(m => _isEqual(m.attrs, model.attrs)).length > 0;\n  }\n\n  /**\n   * @method filter\n   * @param f\n   * @return {Collection}\n   * @public\n   */\n  filter(f) {\n    let filteredModels = this.models.filter(f);\n\n    return new Collection(this.modelName, filteredModels);\n  }\n\n  /**\n   * @method sort\n   * @param f\n   * @return {Collection}\n   * @public\n   */\n  sort(f) {\n    let sortedModels = this.models.concat().sort(f);\n\n    return new Collection(this.modelName, sortedModels);\n  }\n\n  /**\n   * @method slice\n   * @param {Integer} begin\n   * @param {Integer} end\n   * @return {Collection}\n   * @public\n   */\n  slice(...args) {\n    let slicedModels = this.models.slice(...args);\n\n    return new Collection(this.modelName, slicedModels);\n  }\n\n  /**\n   * @method mergeCollection\n   * @param collection\n   * @return this\n   * @public\n   */\n  mergeCollection(collection) {\n    this.models = this.models.concat(collection.models);\n\n    return this;\n  }\n\n  /**\n   * Simple string representation of the collection and id.\n   * @method toString\n   * @return {String}\n   * @public\n   */\n  toString() {\n    return `collection:${this.modelName}(${this.models.map((m) => m.id).join(',')})`;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/orm/model.js":"import { toCollectionName } from 'ember-cli-mirage/utils/normalize-name';\nimport extend from '../utils/extend';\nimport assert from '../assert';\nimport Collection from './collection';\nimport _values from 'lodash/values';\n\n/*\n  The Model class. Notes:\n\n  - We need to pass in modelName, because models are created with\n    .extend and anonymous functions, so you cannot use\n    reflection to find the name of the constructor.\n*/\n\n/*\n  Constructor\n*/\nclass Model {\n\n  // TODO: schema and modelName now set statically at registration, need to remove\n  constructor(schema, modelName, attrs, fks) {\n    assert(schema, 'A model requires a schema');\n    assert(modelName, 'A model requires a modelName');\n\n    this._schema = schema;\n    this.modelName = modelName;\n    this.fks = fks || [];\n    attrs = attrs || {};\n\n    this._setupAttrs(attrs);\n    this._setupRelationships(attrs);\n\n    return this;\n  }\n\n  /**\n   * Creates or saves the model.\n   * @method save\n   * @return this\n   * @public\n   */\n  save() {\n    let collection = toCollectionName(this.modelName);\n\n    if (this.isNew()) {\n      // Update the attrs with the db response\n      this.attrs = this._schema.db[collection].insert(this.attrs);\n\n      // Ensure the id getter/setter is set\n      this._definePlainAttribute('id');\n\n    } else {\n      this._schema.db[collection].update(this.attrs.id, this.attrs);\n    }\n\n    this._saveAssociations();\n\n    return this;\n  }\n\n  /**\n   * Update the record in the db.\n   * @method update\n   * @param {String} key\n   * @param {String} val\n   * @return this\n   * @public\n   */\n  update(key, val) {\n    let attrs;\n    if (key == null) {\n      return this;\n    }\n\n    if (typeof key === 'object') {\n      attrs = key;\n    } else {\n      (attrs = {})[key] = val;\n    }\n\n    Object.keys(attrs).forEach(function(attr) {\n      this._definePlainAttribute(attr);\n      this[attr] = attrs[attr];\n    }, this);\n\n    this.save();\n\n    return this;\n  }\n\n  /**\n   * Destroys the db record\n   * @method destroy\n   * @public\n   */\n  destroy() {\n    if (this.isSaved()) {\n      this._disassociateFromDependents();\n\n      let collection = toCollectionName(this.modelName);\n      this._schema.db[collection].remove(this.attrs.id);\n    }\n  }\n\n  /**\n   * Boolean, true if the model has not been persisted yet to the db.\n   *\n   * Originally this method simply checked if the model had an id; however,\n   * we let people create models with pre-specified ids. So, we have to\n   * check whether the record is in the actual databse or not.\n   *\n   * @method isNew\n   * @return {Boolean}\n   * @public\n   */\n  isNew() {\n    let hasDbRecord = false;\n    let hasId = this.attrs.id !== undefined && this.attrs.id !== null;\n\n    if (hasId) {\n      let collectionName = toCollectionName(this.modelName);\n      let record = this._schema.db[collectionName].find(this.attrs.id);\n      if (record) {\n        hasDbRecord = true;\n      }\n    }\n\n    return !hasDbRecord;\n  }\n\n  /**\n   * Boolean, opposite of `isNew`\n   * @method isSaved\n   * @return {Boolean}\n   * @public\n   */\n  isSaved() {\n    return !this.isNew();\n  }\n\n  /**\n   * Reload a model’s data from the database.\n   * @method reload\n   * @return this\n   * @public\n   */\n  reload() {\n    if (this.id) {\n      let collection = toCollectionName(this.modelName);\n      let attrs = this._schema.db[collection].find(this.id);\n\n      Object.keys(attrs)\n        .filter(function(attr) {\n          return attr !== 'id';\n        })\n        .forEach(function(attr) {\n          this.attrs[attr] = attrs[attr];\n        }, this);\n    }\n\n    // Clear temp associations\n    this._tempAssociations = {};\n\n    return this;\n  }\n\n  toJSON() {\n    return this.attrs;\n  }\n\n  /**\n   * Returns the association for the given key\n   *\n   * @method associationFor\n   * @param key\n   * @public\n   */\n  associationFor(key) {\n    return this._schema.associationsFor(this.modelName)[key];\n  }\n\n  /**\n   * Returns the inverse association, if it exists\n   *\n   * @method inverseAssociationFor\n   * @param key\n   * @public\n   */\n  inverseAssociationFor(key) {\n    return this.associationFor(key).inverse();\n  }\n\n  associate(model, association) {\n    let { key } = association;\n\n    if (association.constructor.name === 'HasMany') {\n      if (!this[key].includes(model)) {\n        this[key].add(model);\n      }\n    } else {\n      this[key] = model;\n    }\n  }\n\n  disassociate(model, association) {\n    let fk = association.getForeignKey();\n\n    if (association.constructor.name === 'HasMany') {\n      let i = this[fk].map(key => key.toString()).indexOf(model.id.toString());\n      if (i > -1) {\n        this.attrs[fk].splice(i, 1);\n      }\n    } else {\n      this.attrs[fk] = null;\n    }\n  }\n\n  // Private\n  /**\n   * model.attrs represents the persistable attributes, i.e. your db\n   * table fields.\n   * @method _setupAttrs\n   * @param attrs\n   * @private\n   */\n  _setupAttrs(attrs) {\n    // Verify no undefined associations are passed in\n    Object.keys(attrs)\n      .filter((key) => {\n        let value = attrs[key];\n        let isModelOrCollection = (value instanceof Model || value instanceof Collection);\n        let isArrayOfModels = Array.isArray(value) && value.length && value.every(item => item instanceof Model);\n\n        return isModelOrCollection || isArrayOfModels;\n      })\n      .forEach((key) => {\n        let modelOrCollection = attrs[key];\n\n        assert(this.associationKeys.indexOf(key) > -1, `You're trying to create a ${this.modelName} model and you passed in a ${modelOrCollection.toString()} under the ${key} key, but you haven't defined that key as an association on your model.`);\n      });\n\n    // Filter out association keys\n    let hash = Object.keys(attrs).reduce((memo, key) => {\n      if (this.associationKeys.indexOf(key) === -1 && this.associationIdKeys.indexOf(key) === -1) {\n        memo[key] = attrs[key];\n      }\n      return memo;\n    }, {});\n\n    // Ensure fks are there\n    this.fks.map(function(fk) {\n      hash[fk] = attrs[fk] !== undefined ? attrs[fk] : null;\n    });\n\n    this.attrs = hash;\n\n    // define plain getter/setters for non-association keys\n    Object.keys(hash).forEach(function(attr) {\n      if (this.associationKeys.indexOf(attr) === -1 && this.associationIdKeys.indexOf(attr) === -1) {\n        this._definePlainAttribute(attr);\n      }\n    }, this);\n  }\n\n  /**\n   * Define getter/setter for a plain attribute\n   * @method _definePlainAttribute\n   * @param attr\n   * @private\n   */\n  _definePlainAttribute(attr) {\n\n    // Ensure the property hasn't already been defined\n    let existingProperty = Object.getOwnPropertyDescriptor(this, attr);\n    if (existingProperty && existingProperty.get) {\n      return;\n    }\n\n    // Ensure the attribute is on the attrs hash\n    if (!this.attrs.hasOwnProperty(attr)) {\n      this.attrs[attr] = null;\n    }\n\n    // Define the getter/setter\n    Object.defineProperty(this, attr, {\n      get() {\n        return this.attrs[attr];\n      },\n      set(val) {\n        this.attrs[attr] = val;\n        return this;\n      }\n    });\n  }\n\n  /**\n   * Foreign keys get set on attrs directly (to avoid potential recursion), but\n   * model references use the setter.\n   *\n   * We validate foreign keys during instantiation.\n   *\n   * @method _setupRelationships\n   * @param attrs\n   * @private\n   */\n  _setupRelationships(attrs) {\n    let foreignKeysHash = Object.keys(attrs).reduce((memo, attr) => {\n      if (this.associationIdKeys.indexOf(attr) > -1 || this.fks.indexOf(attr) > -1) {\n        memo[attr] = attrs[attr];\n      }\n      return memo;\n    }, {});\n\n    Object.keys(foreignKeysHash).forEach(function(attr) {\n      let fk = foreignKeysHash[attr];\n      if (fk !== undefined && fk !== null) {\n        this._validateForeignKeyExistsInDatabase(attr, fk);\n      }\n\n      this.attrs[attr] = fk;\n    }, this);\n\n    let associationKeysHash = Object.keys(attrs).reduce((memo, attr) => {\n      if (this.associationKeys.indexOf(attr) > -1) {\n        memo[attr] = attrs[attr];\n      }\n      return memo;\n    }, {});\n    Object.keys(associationKeysHash).forEach(function(attr) {\n      this[attr] = associationKeysHash[attr];\n    }, this);\n  }\n\n  /**\n   * Originally we validated this via association.setId method, but it triggered\n   * recursion. That method is designed for updating an existing model's ID so\n   * this method is needed during instantiation.\n   *\n   * @method _validateForeignKeyExistsInDatabase\n   * @private\n   */\n  _validateForeignKeyExistsInDatabase(foreignKeyName, foreignKeys) {\n    if (Array.isArray(foreignKeys)) {\n      let associationModelName = Object.keys(this.hasManyAssociations)\n        .map(key => this.hasManyAssociations[key])\n        .filter(association => association.getForeignKey() === foreignKeyName)[0]\n        .modelName;\n\n      let found = this._schema.db[toCollectionName(associationModelName)].find(foreignKeys);\n      assert(found.length === foreignKeys.length, `You're instantiating a ${this.modelName} that has a ${foreignKeyName} of ${foreignKeys}, but some of those records don't exist in the database.`);\n\n    } else {\n      let associationModelName = Object.keys(this.belongsToAssociations)\n        .map(key => this.belongsToAssociations[key])\n        .filter(association => association.getForeignKey() === foreignKeyName)[0]\n        .modelName;\n\n      let found = this._schema.db[toCollectionName(associationModelName)].find(foreignKeys);\n      assert(found, `You're instantiating a ${this.modelName} that has a ${foreignKeyName} of ${foreignKeys}, but that record doesn't exist in the database.`);\n    }\n  }\n\n  /**\n   * Update associated children when saving a collection\n   *\n   * @method _saveAssociations\n   * @private\n   */\n  _saveAssociations() {\n    this._saveBelongsToAssociations();\n    this._saveHasManyAssociations();\n  }\n\n  _saveBelongsToAssociations() {\n    _values(this.belongsToAssociations).forEach(association => {\n      this._disassociateFromOldInverses(association);\n      this._saveNewAssociates(association);\n      this._associateWithNewInverse(association);\n    });\n  }\n\n  _saveHasManyAssociations() {\n    _values(this.hasManyAssociations).forEach(association => {\n      this._disassociateFromOldInverses(association);\n      this._saveNewAssociates(association);\n      this._associateWithNewInverses(association);\n    });\n  }\n\n  _disassociateFromOldInverses(association) {\n    if (association.constructor.name === 'HasMany') {\n      this._disassociateFromHasManyInverses(association);\n    } else if (association.constructor.name === 'BelongsTo') {\n      this._disassociateFromBelongsToInverse(association);\n    }\n  }\n\n  _disassociateFromHasManyInverses(association) {\n    let { key } = association;\n    let fk = association.getForeignKey();\n    let inverse = association.inverse();\n    let tempAssociation = this._tempAssociations && this._tempAssociations[key];\n    let oldInversesExist = this.attrs[fk];\n\n    if (inverse && tempAssociation && oldInversesExist) {\n      // Disassociate currently persisted models that are no longer associated\n      this._schema[toCollectionName(association.modelName)]\n        .find(this.attrs[fk] || []) // TODO: prob should initialize hasMany fks with []\n        .models\n        .filter(model => !tempAssociation.includes(model)) // filter out models that will still be associated\n        .forEach(model => {\n          model.disassociate(this, inverse);\n          model.save();\n        });\n    }\n  }\n\n  _disassociateFromBelongsToInverse(association) {\n    let { key } = association;\n    let fk = association.getForeignKey();\n    let inverse = association.inverse();\n    let tempAssociation = this._tempAssociations && this._tempAssociations[key];\n    let oldInversesExist = this.attrs[fk];\n\n    if (inverse && (tempAssociation !== undefined) && oldInversesExist) {\n      // Disassociate currently persisted models that are no longer associated\n      let model = this._schema[toCollectionName(association.modelName)]\n        .find(this.attrs[fk]);\n\n      model.disassociate(this, inverse);\n      model._updateInDb(model.attrs);\n    }\n  }\n\n  _disassociateFromDependents() {\n    _values(this._schema.dependentAssociationsFor(this.modelName))\n      .forEach(association => {\n        association.disassociateAllDependentsFromTarget(this);\n      });\n  }\n\n  _saveNewAssociates(association) {\n    let { key } = association;\n    let fk = association.getForeignKey();\n    let tempAssociate = this._tempAssociations && this._tempAssociations[key];\n\n    if (tempAssociate !== undefined) {\n      this.__isSavingNewChildren = true;\n      delete this._tempAssociations[key];\n\n      if (tempAssociate instanceof Collection) {\n        tempAssociate.models.forEach(child => {\n          child.save();\n        });\n\n        this._updateInDb({ [fk]: tempAssociate.models.map(child => child.id) });\n      } else {\n\n        if (tempAssociate === null) {\n          this._updateInDb({ [fk]: null });\n        } else {\n          tempAssociate.save();\n          this._updateInDb({ [fk]: tempAssociate.id });\n        }\n      }\n\n      this.__isSavingNewChildren = false;\n    }\n  }\n\n  _associateWithNewInverse(association) {\n    let fk = association.getForeignKey();\n    let inverse = association.inverse();\n\n    if (this[fk] && inverse && (inverse.constructor.name === 'BelongsTo') && !this.__isSavingNewChildren) {\n      let inverseFk = inverse.getForeignKey();\n\n      this._schema.db[toCollectionName(association.modelName)]\n        .update(this[fk], { [inverseFk]: this.id });\n\n    } else if (this[fk] && inverse && (inverse.constructor.name === 'HasMany') && !this.__isSavingNewChildren) {\n      let inverseFk = inverse.getForeignKey();\n      let inverseCollection = this._schema.db[toCollectionName(association.modelName)];\n      let currentIdsForInverse = inverseCollection.find(this[fk])[inverse.getForeignKey()] || [];\n      let newIdsForInverse = currentIdsForInverse;\n\n      if (newIdsForInverse.indexOf(this.id) === -1) {\n        newIdsForInverse.push(this.id);\n      }\n\n      inverseCollection.update(this[fk], { [inverseFk]: newIdsForInverse });\n    }\n  }\n\n  _associateWithNewInverses(association) {\n    let fk = association.getForeignKey();\n    let inverse = association.inverse();\n\n    // Associate new models\n    if (inverse && (inverse.constructor.name === 'HasMany') && !this.__isSavingNewChildren) {\n      this._schema[toCollectionName(association.modelName)]\n        .find(this[fk])\n        .models\n        .forEach(model => {\n          let inverseFk = inverse.getForeignKey();\n          let ownerId = this.id;\n          let inverseCollection = this._schema.db[toCollectionName(model.modelName)];\n          let currentIdsForInverse = inverseCollection.find(model.id)[inverse.getForeignKey()] || [];\n          let newIdsForInverse = currentIdsForInverse;\n\n          if (newIdsForInverse.indexOf(ownerId) === -1) {\n            newIdsForInverse.push(ownerId);\n          }\n\n          inverseCollection.update(model.id, { [inverseFk]: newIdsForInverse });\n        });\n    } else if (inverse && (inverse.constructor.name === 'BelongsTo') && !this.__isSavingNewChildren) {\n      this._schema[toCollectionName(association.modelName)]\n        .find(this[fk])\n        .models\n        .forEach(model => {\n          let inverseFk = inverse.getForeignKey();\n          let ownerId = this.id;\n          let inverseCollection = this._schema.db[toCollectionName(model.modelName)];\n\n          inverseCollection.update(model.id, { [inverseFk]: ownerId });\n        });\n    }\n  }\n\n  // Used to update data directly, since #save and #update can retrigger saves,\n  // which can cause cycles with associations.\n  _updateInDb(attrs) {\n    this.attrs = this._schema.db[toCollectionName(this.modelName)].update(this.attrs.id, attrs);\n  }\n\n  /**\n   * Simple string representation of the model and id.\n   * @method toString\n   * @return {String}\n   * @public\n   */\n  toString() {\n    return `model:${this.modelName}(${this.id})`;\n  }\n}\n\nModel.extend = extend;\nModel.findBelongsToAssociation = function(associationType) {\n  return this.prototype.belongsToAssociations[associationType];\n};\n\nexport default Model;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/orm/schema.js":"import { pluralize, camelize, dasherize } from '../utils/inflector';\nimport { toCollectionName, toModelName } from 'ember-cli-mirage/utils/normalize-name';\nimport Association from './associations/association';\nimport Collection from './collection';\nimport _assign from 'lodash/assign';\nimport _forIn from 'lodash/forIn';\nimport _includes from 'lodash/includes';\nimport assert from '../assert';\n\n/**\n * @class Schema\n * @constructor\n * @public\n */\nexport default class Schema {\n\n  constructor(db, modelsMap = {}) {\n    assert(db, 'A schema requires a db');\n\n    this.db = db;\n    this._registry = {};\n    this._dependentAssociations = {};\n    this.registerModels(modelsMap);\n  }\n\n  /**\n   * @method registerModels\n   * @param hash\n   * @public\n   */\n  registerModels(hash = {}) {\n    _forIn(hash, (model, key) => {\n      this.registerModel(key, hash[key]);\n    });\n  }\n\n  /**\n   * @method registerModel\n   * @param type\n   * @param ModelClass\n   * @public\n   */\n  registerModel(type, ModelClass) {\n    let camelizedModelName = camelize(type);\n    let modelName = dasherize(camelizedModelName);\n\n    // Avoid mutating original class, because we may want to reuse it across many tests\n    ModelClass = ModelClass.extend();\n\n    // Store model & fks in registry\n    // TODO: don't think this is needed anymore\n    this._registry[camelizedModelName] = this._registry[camelizedModelName] || { class: null, foreignKeys: [] }; // we may have created this key before, if another model added fks to it\n    this._registry[camelizedModelName].class = ModelClass;\n\n    // TODO: set here, remove from model#constructor\n    ModelClass.prototype._schema = this;\n    ModelClass.prototype.modelName = modelName;\n    // Set up associations\n    ModelClass.prototype.hasManyAssociations = {};   // a registry of the model's hasMany associations. Key is key from model definition, value is association instance itself\n    ModelClass.prototype.belongsToAssociations = {}; // a registry of the model's belongsTo associations. Key is key from model definition, value is association instance itself\n    ModelClass.prototype.associationKeys = [];       // ex: address.user, user.addresses\n    ModelClass.prototype.associationIdKeys = [];     // ex: address.user_id, user.address_ids\n    ModelClass.prototype.dependentAssociations = []; // a registry of associations that depend on this model, needed for deletion cleanup.\n\n    let fksAddedFromThisModel = {};\n    for (let associationProperty in ModelClass.prototype) {\n      if (ModelClass.prototype[associationProperty] instanceof Association) {\n        let association = ModelClass.prototype[associationProperty];\n        association.key = associationProperty;\n        association.modelName = association.modelName || toModelName(associationProperty);\n        association.ownerModelName = modelName;\n        association.setSchema(this);\n\n        // Update the registry with this association's foreign keys. This is\n        // essentially our \"db migration\", since we must know about the fks.\n        let [fkHolder, fk] = association.getForeignKeyArray();\n\n        fksAddedFromThisModel[fkHolder] = fksAddedFromThisModel[fkHolder] || [];\n        assert(\n          !_includes(fksAddedFromThisModel[fkHolder], fk),\n          `Your '${type}' model definition has multiple possible inverse relationships of type '${fkHolder}'.\n\n          Please read the associations guide and specify explicit inverses: http://www.ember-cli-mirage.com/docs/v0.2.x/models/#associations`\n        );\n        fksAddedFromThisModel[fkHolder].push(fk);\n\n        this._addForeignKeyToRegistry(fkHolder, fk);\n\n        // Augment the Model's class with any methods added by this association\n        association.addMethodsToModelClass(ModelClass, associationProperty);\n      }\n    }\n\n    // Create a db collection for this model, if doesn't exist\n    let collection = toCollectionName(modelName);\n    if (!this.db[collection]) {\n      this.db.createCollection(collection);\n    }\n\n    // Create the entity methods\n    this[collection] = {\n      camelizedModelName,\n      new: (attrs) => this.new(camelizedModelName, attrs),\n      create: (attrs) => this.create(camelizedModelName, attrs),\n      all: (attrs) => this.all(camelizedModelName, attrs),\n      find: (attrs) => this.find(camelizedModelName, attrs),\n      findBy: (attrs) => this.findBy(camelizedModelName, attrs),\n      where: (attrs) => this.where(camelizedModelName, attrs),\n      first: (attrs) => this.first(camelizedModelName, attrs)\n    };\n\n    return this;\n  }\n\n  /**\n   * @method modelFor\n   * @param type\n   * @public\n   */\n  modelFor(type) {\n    return this._registry[type];\n  }\n\n  /**\n   * @method new\n   * @param type\n   * @param attrs\n   * @public\n   */\n  new(type, attrs) {\n\n    // let fk = foreignKeysHash[attr];\n    // debugger;\n    // assert(\n    //   !fk || this.schema.db[toCollectionName(association.modelName)].find(fk),\n    //   `Couldn\\'t find ${association.modelName} with id = ${fk}`\n    // );\n\n    // this[attr] = fk;\n    return this._instantiateModel(dasherize(type), attrs);\n  }\n\n  /**\n   * @method create\n   * @param type\n   * @param attrs\n   * @public\n   */\n  create(type, attrs) {\n    return this.new(type, attrs).save();\n  }\n\n  /**\n   * @method all\n   * @param type\n   * @public\n   */\n  all(type) {\n    let collection = this._collectionForType(type);\n\n    return this._hydrate(collection, dasherize(type));\n  }\n\n  /**\n   * @method find\n   * @param type\n   * @param ids\n   * @public\n   */\n  find(type, ids) {\n    let collection = this._collectionForType(type);\n    let records = collection.find(ids);\n\n    if (Array.isArray(ids)) {\n      assert(\n        records.length === ids.length,\n        `Couldn't find all ${pluralize(type)} with ids: (${ids.join(',')}) (found ${records.length} results, but was looking for ${ids.length})`\n      );\n    }\n\n    return this._hydrate(records, dasherize(type));\n  }\n\n  /**\n   * @method findBy\n   * @param type\n   * @param attributeName\n   * @public\n   */\n  findBy(type, query) {\n    let collection = this._collectionForType(type);\n    let records = collection.findBy(query);\n\n    return this._hydrate(records, dasherize(type));\n  }\n\n  /**\n   * @method where\n   * @param type\n   * @param query\n   * @public\n   */\n  where(type, query) {\n    let collection = this._collectionForType(type);\n    let records = collection.where(query);\n\n    return this._hydrate(records, dasherize(type));\n  }\n\n  /**\n   * @method first\n   * @param type\n   * @public\n   */\n  first(type) {\n    let collection = this._collectionForType(type);\n    let [record] = collection;\n\n    return this._hydrate(record, dasherize(type));\n  }\n\n  modelClassFor(modelName) {\n    return this._registry[camelize(modelName)].class.prototype;\n  }\n\n  addDependentAssociation(association, modelName) {\n    this._dependentAssociations[modelName] = this._dependentAssociations[modelName] || [];\n    this._dependentAssociations[modelName].push(association);\n  }\n\n  dependentAssociationsFor(modelName) {\n    return this._dependentAssociations[modelName];\n  }\n\n  associationsFor(modelName) {\n    let modelClass = this.modelClassFor(modelName);\n\n    return _assign({}, modelClass.belongsToAssociations, modelClass.hasManyAssociations);\n  }\n\n  /*\n    Private methods\n  */\n\n  /**\n   * @method _collectionForType\n   * @param type\n   * @private\n   */\n  _collectionForType(type) {\n    let collection = toCollectionName(type);\n    assert(\n      this.db[collection],\n      `You're trying to find model(s) of type ${type} but this collection doesn't exist in the database.`\n    );\n\n    return this.db[collection];\n  }\n\n  /**\n   * @method _addForeignKeyToRegistry\n   * @param type\n   * @param fk\n   * @private\n   */\n  _addForeignKeyToRegistry(type, fk) {\n    this._registry[type] = this._registry[type] || { class: null, foreignKeys: [] };\n\n    let fks = this._registry[type].foreignKeys;\n    if (!_includes(fks, fk)) {\n      fks.push(fk);\n    }\n  }\n\n  /**\n   * @method _instantiateModel\n   * @param modelName\n   * @param attrs\n   * @private\n   */\n  _instantiateModel(modelName, attrs) {\n    let ModelClass = this._modelFor(modelName);\n    let fks = this._foreignKeysFor(modelName);\n\n    return new ModelClass(this, modelName, attrs, fks);\n  }\n\n  /**\n   * @method _modelFor\n   * @param modelName\n   * @private\n   */\n  _modelFor(modelName) {\n    return this._registry[camelize(modelName)].class;\n  }\n\n  /**\n   * @method _foreignKeysFor\n   * @param modelName\n   * @private\n   */\n  _foreignKeysFor(modelName) {\n    return this._registry[camelize(modelName)].foreignKeys;\n  }\n\n  /**\n   * Takes a record and returns a model, or an array of records\n   * and returns a collection.\n   *\n   * @method _hydrate\n   * @param records\n   * @param modelName\n   * @private\n   */\n  _hydrate(records, modelName) {\n    if (Array.isArray(records)) {\n      let models = records.map(function(record) {\n        return this._instantiateModel(modelName, record);\n      }, this);\n      return new Collection(modelName, models);\n    } else if (records) {\n      return this._instantiateModel(modelName, records);\n    } else {\n      return null;\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/base.js":"import assert from 'ember-cli-mirage/assert';\nimport { camelize, singularize, dasherize } from 'ember-cli-mirage/utils/inflector';\n\nexport default class BaseRouteHandler {\n\n  getModelClassFromPath(fullPath) {\n    if (!fullPath) {\n      return;\n    }\n    let path = fullPath.split('/');\n    let lastPath;\n    while (path.length > 0) {\n      lastPath = path.splice(-1)[0];\n      if (lastPath && lastPath !== ':id') {\n        break;\n      }\n    }\n    let modelName = dasherize(camelize(singularize(lastPath)));\n    return modelName;\n  }\n\n  _getIdForRequest(request, jsonApiDoc) {\n    let id;\n    if (request && request.params && request.params.id) {\n      id = request.params.id;\n    } else if (jsonApiDoc && jsonApiDoc.data && jsonApiDoc.data.id) {\n      id = jsonApiDoc.data.id;\n    }\n    return id;\n  }\n\n  _getJsonApiDocForRequest(request, modelName) {\n    let body;\n    if (request && request.requestBody) {\n      body = JSON.parse(request.requestBody);\n    }\n    return this.serializerOrRegistry.normalize(body, modelName);\n  }\n\n  _getAttrsForRequest(request, modelName) {\n    let json = this._getJsonApiDocForRequest(request, modelName);\n    let id = this._getIdForRequest(request, json);\n    let attrs = {};\n\n    assert(\n      json.data && (json.data.attributes || json.data.type || json.data.relationships),\n      `You're using a shorthand or #normalizedRequestAttrs, but your serializer's normalize function did not return a valid JSON:API document. http://www.ember-cli-mirage.com/docs/v0.2.x/serializers/#normalizejson`\n    );\n\n    if (json.data.attributes) {\n      attrs = Object.keys(json.data.attributes).reduce((sum, key) => {\n        sum[camelize(key)] = json.data.attributes[key];\n        return sum;\n      }, {});\n    }\n\n    if (json.data.relationships) {\n      Object.keys(json.data.relationships).forEach((key) => {\n        let relationship = json.data.relationships[key];\n\n        if (!Array.isArray(relationship.data)) {\n          attrs[`${camelize(key)}Id`] = relationship.data && relationship.data.id;\n        }\n      }, {});\n    }\n\n    if (id) {\n      attrs.id = id;\n    }\n\n    return attrs;\n  }\n\n  _getAttrsForFormRequest({ requestBody }) {\n    let attrs;\n    let urlEncodedParts = [];\n\n    assert(\n      requestBody && typeof requestBody === 'string',\n      `You're using the helper method #normalizedFormData, but the request body is empty or not a valid url encoded string.`\n    );\n\n    urlEncodedParts = requestBody.split('&');\n\n    attrs = urlEncodedParts.reduce((a, urlEncodedPart) => {\n      let [key, value] = urlEncodedPart.split('=');\n      a[key] = decodeURIComponent(value.replace(/\\+/g,  ' '));\n      return a;\n    }, {});\n\n    return attrs;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/function.js":"import BaseRouteHandler from './base';\n\nexport default class FunctionRouteHandler extends BaseRouteHandler {\n\n  constructor(schema, serializerOrRegistry, userFunction, path) {\n    super();\n    this.schema = schema;\n    this.serializerOrRegistry = serializerOrRegistry;\n    this.userFunction = userFunction;\n    this.path = path;\n  }\n\n  handle(request) {\n    return this.userFunction(this.schema, request);\n  }\n\n  setRequest(request) {\n    this.request = request;\n  }\n\n  serialize(response, serializerType) {\n    let serializer;\n\n    if (serializerType) {\n      serializer = this.serializerOrRegistry.serializerFor(serializerType, { explicit: true });\n    } else {\n      serializer = this.serializerOrRegistry;\n    }\n\n    return serializer.serialize(response, this.request);\n  }\n\n  normalizedRequestAttrs() {\n    let {\n      path,\n      request,\n      request: { requestHeaders }\n    } = this;\n\n    let modelName = this.getModelClassFromPath(path);\n\n    if (/x-www-form-urlencoded/.test(requestHeaders['Content-Type'])) {\n      return this._getAttrsForFormRequest(request);\n    } else {\n      return this._getAttrsForRequest(request, modelName);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/object.js":"export default class ObjectRouteHandler {\n\n  constructor(schema, serializerOrRegistry, object) {\n    this.schema = schema;\n    this.serializerOrRegistry = serializerOrRegistry;\n    this.object = object;\n  }\n\n  handle(/* request */) {\n    return this.object;\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/serializers/active-model-serializer.js":"import Serializer from '../serializer';\nimport { underscore, pluralize, dasherize, singularize } from '../utils/inflector';\n\nexport default Serializer.extend({\n\n  keyForModel(type) {\n    return underscore(type);\n  },\n\n  keyForAttribute(attr) {\n    return underscore(attr);\n  },\n\n  keyForRelationship(type) {\n    return pluralize(underscore(type));\n  },\n\n  keyForEmbeddedRelationship(attributeName) {\n    return underscore(attributeName);\n  },\n\n  keyForRelationshipIds(type) {\n    return `${underscore(singularize(type))}_ids`;\n  },\n\n  keyForForeignKey(relationshipName) {\n    return `${underscore(relationshipName)}_id`;\n  },\n\n  normalize(payload) {\n    let type = Object.keys(payload)[0];\n    let attrs = payload[type];\n\n    let jsonApiPayload = {\n      data: {\n        type: pluralize(type),\n        attributes: {}\n      }\n    };\n    if (attrs.id) {\n      jsonApiPayload.data.id = attrs.id;\n    }\n    Object.keys(attrs).forEach((key) => {\n      if (key !== 'id') {\n        jsonApiPayload.data.attributes[dasherize(key)] = attrs[key];\n      }\n    });\n\n    return jsonApiPayload;\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/serializers/json-api-serializer.js":"import Serializer from '../serializer';\nimport { dasherize, pluralize, camelize } from '../utils/inflector';\n\nimport _get from 'lodash/get';\nimport _ from 'lodash';\n\nexport default Serializer.extend({\n\n  keyForModel(modelName) {\n    return dasherize(modelName);\n  },\n\n  keyForCollection(modelName) {\n    return dasherize(modelName);\n  },\n\n  keyForAttribute(attr) {\n    return dasherize(attr);\n  },\n\n  keyForRelationship(key) {\n    return dasherize(key);\n  },\n\n  getHashForPrimaryResource(resource) {\n    let resourceHash = this.getHashForResource(resource);\n    let hashWithRoot = { data: resourceHash };\n    let addToIncludes = this.getAddToIncludesForResource(resource);\n\n    return [ hashWithRoot, addToIncludes ];\n  },\n\n  getHashForIncludedResource(resource) {\n    let serializer = this.serializerFor(resource.modelName);\n    let hash = serializer.getHashForResource(resource);\n    let hashWithRoot = { included: (this.isModel(resource) ? [ hash ] : hash) };\n    let addToIncludes = [];\n\n    if (!this.hasQueryParamIncludes()) {\n      addToIncludes = this.getAddToIncludesForResource(resource);\n    }\n\n    return [ hashWithRoot, addToIncludes ];\n  },\n\n  getHashForResource(resource) {\n    let hash;\n\n    if (this.isModel(resource)) {\n      hash = this._getResourceObjectForModel(resource);\n    } else {\n      hash = resource.models.map((m) => this._getResourceObjectForModel(m));\n    }\n\n    return hash;\n  },\n\n  /*\n    Returns a flat unique list of resources that need to be added to includes\n  */\n  getAddToIncludesForResource(resource) {\n    let relationshipPaths;\n\n    if (_get(this, 'request.queryParams.include')) {\n      relationshipPaths = this.request.queryParams.include.split(',');\n    } else {\n      let serializer = this.serializerFor(resource.modelName);\n      relationshipPaths = serializer.getKeysForIncluded();\n    }\n\n    return this.getAddToIncludesForResourceAndPaths(resource, relationshipPaths);\n  },\n\n  getAddToIncludesForResourceAndPaths(resource, relationshipPaths) {\n    let includes = [];\n\n    relationshipPaths.forEach((path) => {\n      let relationshipNames = path.split('.');\n      let newIncludes = this.getIncludesForResourceAndPath(resource, ...relationshipNames);\n      includes.push(newIncludes);\n    });\n\n    return _(includes)\n      .flatten()\n      .compact()\n      .uniqBy(m => m.toString())\n      .value();\n  },\n\n  getIncludesForResourceAndPath(resource, ...names) {\n    let nameForCurrentResource = camelize(names.shift());\n    let includes = [];\n    let modelsToAdd = [];\n\n    if (this.isModel(resource)) {\n      let relationship = resource[nameForCurrentResource];\n\n      if (this.isModel(relationship)) {\n        modelsToAdd = [ relationship ];\n      } else if (this.isCollection(relationship)) {\n        modelsToAdd = relationship.models;\n      }\n\n    } else {\n      resource.models.forEach((model) => {\n        let relationship = model[nameForCurrentResource];\n\n        if (this.isModel(relationship)) {\n          modelsToAdd.push(relationship);\n        } else if (this.isCollection(relationship)) {\n          modelsToAdd = modelsToAdd.concat(relationship.models);\n        }\n      });\n    }\n\n    includes = includes.concat(modelsToAdd);\n\n    if (names.length) {\n      modelsToAdd.forEach((model) => {\n        includes = includes.concat(this.getIncludesForResourceAndPath(model, ...names));\n      });\n    }\n\n    return includes;\n  },\n\n  _getResourceObjectForModel(model) {\n    let attrs = this._attrsForModel(model, true);\n    delete attrs.id;\n\n    let hash = {\n      type: this.typeKeyForModel(model),\n      id: model.id,\n      attributes: attrs\n    };\n\n    model.associationKeys.forEach((key) => {\n      let relationship = model[key];\n      let relationshipKey = this.keyForRelationship(key);\n      let relationshipHash;\n      hash.relationships = hash.relationships || {};\n\n      if (this.hasLinksForRelationship(model, key)) {\n        let serializer = this.serializerFor(model.modelName);\n        let links = serializer.links(model);\n        relationshipHash = { links: links[key] };\n\n      } else {\n        let data = null;\n\n        if (this.isModel(relationship)) {\n          data = {\n            type: this.typeKeyForModel(relationship),\n            id: relationship.id\n          };\n        } else if (this.isCollection(relationship)) {\n          data = relationship.models.map((model) => {\n            return {\n              type: this.typeKeyForModel(model),\n              id: model.id\n            };\n          });\n        }\n\n        relationshipHash = { data };\n      }\n\n      hash.relationships[relationshipKey] = relationshipHash;\n    });\n\n    return hash;\n  },\n\n  hasLinksForRelationship(model, relationshipKey) {\n    let serializer = this.serializerFor(model.modelName);\n    let links;\n    if (serializer.links) {\n      links = serializer.links(model);\n\n      return links[relationshipKey] != null;\n    }\n  },\n\n  getQueryParamIncludes() {\n    return (_get(this, 'request.queryParams.include'));\n  },\n\n  hasQueryParamIncludes() {\n    return !!this.getQueryParamIncludes();\n  },\n\n  typeKeyForModel(model) {\n    return dasherize(pluralize(model.modelName));\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/serializers/rest-serializer.js":"import ActiveModelSerializer from './active-model-serializer';\nimport { camelize, singularize, pluralize } from '../utils/inflector';\n\nexport default ActiveModelSerializer.extend({\n\n  keyForModel(type) {\n    return camelize(type);\n  },\n\n  keyForAttribute(attr) {\n    return camelize(attr);\n  },\n\n  keyForRelationship(type) {\n    return camelize(pluralize(type));\n  },\n\n  keyForEmbeddedRelationship(attributeName) {\n    return camelize(attributeName);\n  },\n\n  keyForRelationshipIds(type) {\n    return camelize(pluralize(type));\n  },\n\n  keyForForeignKey(relationshipName) {\n    return camelize(singularize(relationshipName));\n  }\n\n});\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/utils/extend.js":"import _assign from 'lodash/assign';\nimport _has from 'lodash/has';\n\nexport default function(protoProps, staticProps) {\n  let parent = this;\n  let child;\n\n  // The constructor function for the new subclass is either defined by you\n  // (the \"constructor\" property in your `extend` definition), or defaulted\n  // by us to simply call the parent's constructor.\n  if (protoProps && _has(protoProps, 'constructor')) {\n    child = protoProps.constructor;\n  } else {\n    child = function() {\n      return parent.apply(this, arguments);\n    };\n  }\n\n  // Add static properties to the constructor function, if supplied.\n\n  _assign(child, parent, staticProps);\n\n  // Set the prototype chain to inherit from `parent`, without calling\n  // `parent`'s constructor function.\n  let Surrogate = function() {\n    this.constructor = child;\n  };\n\n  Surrogate.prototype = parent.prototype;\n  child.prototype = new Surrogate();\n\n  // Add prototype properties (instance properties) to the subclass,\n  // if supplied.\n  if (protoProps) {\n    _assign(child.prototype, protoProps);\n  }\n  // if (protoProps) { _assign(child.prototype, protoProps); }\n\n  // Set a convenience property in case the parent's prototype is needed\n  // later.\n  child.__super__ = parent.prototype;\n\n  return child;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/utils/inflector.js":"import Ember from 'ember';\nexport { singularize, pluralize } from 'ember-inflector';\n\nexport var capitalize = Ember.String.capitalize;\nexport var camelize = Ember.String.camelize;\nexport var dasherize = Ember.String.dasherize;\nexport var underscore = Ember.String.underscore;\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/utils/is-association.js":"import _isPlainObject from 'lodash/isPlainObject';\n\nexport default function(object) {\n  return _isPlainObject(object) && object.__isAssociation__ === true;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/utils/normalize-name.js":"import {\n  camelize,\n  pluralize,\n  singularize,\n  dasherize\n} from 'ember-cli-mirage/utils/inflector';\n\nexport function toCollectionName(type) {\n  let modelName = dasherize(type);\n  return camelize(pluralize(modelName));\n}\n\nexport function toModelName(type) {\n  let modelName = dasherize(type);\n  return singularize(modelName);\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/utils/read-modules.js":"/* global requirejs, require */\n/* eslint-env node */\n'use strict';\n\nimport Ember from 'ember';\nimport _camelCase from 'lodash/camelCase';\nimport { pluralize } from 'ember-cli-mirage/utils/inflector';\nimport require from 'require';\n\nconst { assert } = Ember;\n\n/*\n  This function looks through all files that have been loaded by Ember CLI and\n  finds the ones under /mirage/[factories, fixtures, scenarios, models]/, and exports\n  a hash containing the names of the files as keys and the data as values.\n*/\nexport default function(prefix) {\n  let modules = ['factories', 'fixtures', 'scenarios', 'models', 'serializers'];\n  let mirageModuleRegExp = new RegExp(`^${prefix}/mirage/(${modules.join('|')})`);\n  let modulesMap = modules.reduce((memo, name) => {\n    memo[name] = {};\n    return memo;\n  }, {});\n\n  Object.keys(requirejs.entries).filter(function(key) {\n    return mirageModuleRegExp.test(key);\n  }).forEach(function(moduleName) {\n    if (moduleName.match('.jshint')) { // ignore autogenerated .jshint files\n      return;\n    }\n    let moduleParts = moduleName.split('/');\n    let moduleType = moduleParts[moduleParts.length - 2];\n    let moduleKey = moduleParts[moduleParts.length - 1];\n    assert(`Subdirectories under ${moduleType} are not supported`,\n                 moduleParts[moduleParts.length - 3] === 'mirage');\n\n    if (moduleType === 'scenario') {\n      assert('Only scenario/default.js is supported at this time.',\n                   moduleKey !== 'default');\n    }\n\n    /*\n      Ensure fixture keys are pluralized\n    */\n    if (moduleType === 'fixtures') {\n      moduleKey = pluralize(moduleKey);\n    }\n\n    let module = require(moduleName, null, null, true);\n    if (!module) {\n      throw new Error(`${moduleName} must export a ${moduleType}`);\n    }\n\n    let data = module.default;\n\n    modulesMap[moduleType][_camelCase(moduleKey)] = data;\n  });\n\n  return modulesMap;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/utils/reference-sort.js":"// jscs:disable disallowVar, requireArrayDestructuring\nimport _uniq from 'lodash/uniq';\nimport _flatten from 'lodash/flatten';\n\nexport default function(edges) {\n  let nodes = _uniq(_flatten(edges));\n  let cursor = nodes.length;\n  let sorted = new Array(cursor);\n  let visited = {};\n  let i = cursor;\n\n  let visit = function(node, i, predecessors) {\n\n    if (predecessors.indexOf(node) >= 0) {\n      throw new Error(`Cyclic dependency in properties ${JSON.stringify(predecessors)}`);\n    }\n\n    if (visited[i]) {\n      return;\n    } else {\n      visited[i] = true;\n    }\n\n    let outgoing = edges.filter(function(edge) {\n      return edge && edge[0] === node;\n    });\n    i = outgoing.length;\n    if (i) {\n      let preds = predecessors.concat(node);\n      do {\n        let pair = outgoing[--i];\n        let child = pair[1];\n        if (child) {\n          visit(child, nodes.indexOf(child), preds);\n        }\n      } while (i);\n    }\n\n    sorted[--cursor] = node;\n  };\n\n  while (i--) {\n    if (!visited[i]) {\n      visit(nodes[i], i, []);\n    }\n  }\n\n  return sorted.reverse();\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/utils/uuid.js":"/*\n  UUID generator\n*/\nexport default function() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/app/initializers/ember-cli-mirage.js":"import readModules from 'ember-cli-mirage/utils/read-modules';\nimport ENV from '../config/environment';\nimport baseConfig, { testConfig } from '../mirage/config';\nimport Server from 'ember-cli-mirage/server';\nimport _assign from 'lodash/assign';\n\nexport default {\n  name: 'ember-cli-mirage',\n  initialize: function(application) {\n    if (arguments.length > 1) { // Ember < 2.1\n      var container = arguments[0],\n          application = arguments[1];\n    }\n\n    if (_shouldUseMirage(ENV.environment, ENV['ember-cli-mirage'])) {\n      startMirage(ENV);\n    }\n  }\n};\n\nexport function startMirage(env = ENV) {\n  let environment = env.environment;\n  let modules = readModules(env.modulePrefix);\n  let options = _assign(modules, {environment, baseConfig, testConfig});\n\n  return new Server(options);\n}\n\nfunction _shouldUseMirage(env, addonConfig) {\n  let userDeclaredEnabled = typeof addonConfig.enabled !== 'undefined';\n  let defaultEnabled = _defaultEnabled(env, addonConfig);\n\n  return userDeclaredEnabled ? addonConfig.enabled : defaultEnabled;\n}\n\n/*\n  Returns a boolean specifying the default behavior for whether\n  to initialize Mirage.\n*/\nfunction _defaultEnabled(env, addonConfig) {\n  let usingInDev = env === 'development' && !addonConfig.usingProxy;\n  let usingInTest = env === 'test';\n\n  return usingInDev || usingInTest;\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/blueprints/ember-cli-mirage/index.js":"/* eslint-env node */\n\n'use strict';\n\nvar path = require('path');\nvar existsSync = require('exists-sync');\nvar chalk = require('chalk');\nvar EOL = require('os').EOL;\n\nmodule.exports = {\n  normalizeEntityName: function() {\n    // this prevents an error when the entityName is\n    // not specified (since that doesn't actually matter\n    // to us\n  },\n\n  fileMapTokens: function() {\n    var self = this;\n    return {\n      __root__: function(options) {\n        if (!!self.project.config()['ember-cli-mirage'] && !!self.project.config()['ember-cli-mirage'].directory) {\n          return self.project.config()['ember-cli-mirage'].directory;\n        } else if (options.inAddon) {\n          return path.join('tests', 'dummy', 'mirage');\n        } else {\n          return '/mirage';\n        }\n      }\n    };\n  },\n\n  afterInstall: function() {\n    return this.insertIntoFile('.jshintrc', '    \"server\",', {\n      after: '\"predef\": [\\n'\n    }).then(() => {\n      return this.insertIntoFile('tests/.jshintrc', '    \"server\",', {\n        after: '\"predef\": [\\n'\n      }).then(() =>{\n        if (existsSync('tests/helpers/destroy-app.js')) {\n          var shutdownText = '  if(window.server) {\\n    window.server.shutdown();\\n  }';\n          return this.insertIntoFile('tests/helpers/destroy-app.js', shutdownText, {\n            after: \"Ember.run(application, 'destroy');\\n\"\n          });\n        } else {\n          this.ui.writeLine(\n            EOL +\n            chalk.yellow(\n              '******************************************************' + EOL +\n              'destroy-app.js helper is not present. Please read this' + EOL +\n              'https://gist.github.com/blimmer/35d3efbb64563029505a' + EOL +\n              'to see how to fix the problem.' + EOL +\n              '******************************************************' + EOL\n            )\n          );\n        }\n      });\n    });\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/orm/associations/association.js":"import Model from '../model';\nimport { dasherize } from 'ember-cli-mirage/utils/inflector';\n\nexport default class Association {\n\n  constructor(modelName, opts) {\n    if (typeof modelName === 'object') {\n      // Received opts only\n      this.modelName = undefined;\n      this.opts = modelName;\n    } else {\n      // The modelName of the association. (Might not be passed in - set later\n      // by schema).\n      this.modelName = modelName ? dasherize(modelName) : '';\n      this.opts = opts || {};\n    }\n\n    // The key pointing to the association\n    this.key = '';\n\n    // The modelName that owns this association\n    this.ownerModelName = '';\n  }\n\n  /**\n   * A setter for schema, since we don't have a reference at constuction time.\n   *\n   * @method setSchema\n   * @public\n  */\n  setSchema(schema) {\n    this.schema = schema;\n  }\n\n  /**\n   * Returns this association's inverse, if it exists\n   *\n   * @method inverse\n   * @return {Object} the inverse association\n   * @public\n  */\n  inverse() {\n    let inverse;\n\n    if (this.opts.inverse === null) {\n      inverse = null;\n\n    } else {\n      let associationsMap = this.schema.associationsFor(this.modelName);\n      let explicitInverse = this.opts.inverse;\n      if (explicitInverse) {\n        inverse = associationsMap[explicitInverse];\n      } else {\n        let matches = Object.keys(associationsMap)\n          .map(key => associationsMap[key])\n          .filter(association => association.modelName === this.ownerModelName);\n\n        if (matches.length === 1) {\n          inverse = matches[0];\n        } else {\n          inverse = null;\n        }\n      }\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Returns true if the association is reflexive.\n   *\n   * @method isReflexive\n   * @return {Boolean}\n   * @public\n  */\n  isReflexive() {\n    let isExplicitReflexive = !!(this.modelName === this.ownerModelName && this.opts.inverse);\n    let isImplicitReflexive = !!(this.opts.inverse === undefined && this.ownerModelName === this.modelName);\n\n    return isExplicitReflexive || isImplicitReflexive;\n  }\n\n  /**\n   * Used to check if models match each other. If models are saved, we check model type\n   * and id, since they could have other non-persisted properties that are different.\n   *\n   * @public\n  */\n  inversesAlreadyAssociated(inverse, owner) {\n    let inverseKey = this.inverse().key;\n    let inverseAssociation = inverse[inverseKey];\n\n    if (inverseAssociation && owner) {\n      if (inverseAssociation instanceof Model) {\n        if (inverseAssociation.isSaved() && owner.isSaved()) {\n          return inverseAssociation.toString() === owner.toString();\n        } else {\n          return inverseAssociation === owner;\n        }\n      } else {\n        return inverseAssociation.includes(owner);\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/orm/associations/belongs-to.js":"import Association from './association';\nimport _assign from 'lodash/assign';\nimport { capitalize, camelize } from 'ember-cli-mirage/utils/inflector';\nimport { toCollectionName } from 'ember-cli-mirage/utils/normalize-name';\nimport assert from 'ember-cli-mirage/assert';\n\n/**\n * The belongsTo association adds a fk to the owner of the association\n *\n * @class BelongsTo\n * @extends Association\n * @constructor\n * @public\n */\nexport default class BelongsTo extends Association {\n\n  /**\n   * @method getForeignKeyArray\n   * @return {Array} Array of camelized name of the model owning the association\n   * and foreign key for the association\n   * @public\n   */\n  getForeignKeyArray() {\n    return [camelize(this.ownerModelName), this.getForeignKey()];\n  }\n\n  /**\n   * @method getForeignKey\n   * @return {String} Foreign key for the association\n   * @public\n   */\n  getForeignKey() {\n    return `${camelize(this.key)}Id`;\n  }\n\n  /**\n   * registers belongs-to association defined by given key on given model,\n   * defines getters / setters for associated parent and associated parent's id,\n   * adds methods for creating unsaved parent record and creating a saved one\n   *\n   * @method addMethodsToModelClass\n   * @param {Function} ModelClass\n   * @param {String} key the named key for the association\n   * @public\n   */\n  addMethodsToModelClass(ModelClass, key) {\n    let modelPrototype = ModelClass.prototype;\n    let association = this;\n    let foreignKey = this.getForeignKey();\n    let associationHash = { [key]: this };\n\n    modelPrototype.belongsToAssociations = _assign(modelPrototype.belongsToAssociations, associationHash);\n\n    // Add to target's dependent associations array\n    this.schema.addDependentAssociation(this, this.modelName);\n\n    // TODO: look how this is used. Are these necessary, seems like they could be gotten from the above?\n    // Or we could use a single data structure to store this information?\n    modelPrototype.associationKeys.push(key);\n    modelPrototype.associationIdKeys.push(foreignKey);\n\n    Object.defineProperty(modelPrototype, foreignKey, {\n\n      /*\n        object.parentId\n          - returns the associated parent's id\n      */\n      get() {\n        this._tempAssociations = this._tempAssociations || {};\n        let tempParent = this._tempAssociations[key];\n        let id;\n\n        if (tempParent === null) {\n          id = null;\n        } else if (tempParent) {\n          id = tempParent.id;\n        } else {\n          id = this.attrs[foreignKey];\n        }\n\n        return id;\n      },\n\n      /*\n        object.parentId = (parentId)\n          - sets the associated parent via id\n      */\n      set(id) {\n        let tempParent;\n\n        if (id === null) {\n          tempParent = null;\n        } else if (id !== undefined) {\n          tempParent = association.schema[toCollectionName(association.modelName)].find(id);\n          assert(tempParent, `Couldn\\'t find ${association.modelName} with id = ${id}`);\n        }\n\n        this[key] = tempParent;\n      }\n    });\n\n    Object.defineProperty(modelPrototype, key, {\n      /*\n        object.parent\n          - returns the associated parent\n      */\n      get() {\n        this._tempAssociations = this._tempAssociations || {};\n\n        let tempParent = this._tempAssociations[key];\n        let foreignKeyId = this[foreignKey];\n        let model = null;\n\n        if (tempParent) {\n          model = tempParent;\n        } else if (foreignKeyId !== null) {\n          model = association.schema[toCollectionName(association.modelName)].find(foreignKeyId);\n        }\n\n        return model;\n      },\n\n      /*\n        object.parent = (parentModel)\n          - sets the associated parent via model\n      */\n      set(model) {\n        this._tempAssociations = this._tempAssociations || {};\n        this._tempAssociations[key] = model;\n\n        if (\n          model\n          && association.inverse()\n          && !association.inversesAlreadyAssociated(model, this) // check for an existing match, to avoid recursion\n        )  {\n          model.associate(this, association.inverse());\n        }\n      }\n    });\n\n    /*\n      object.newParent\n        - creates a new unsaved associated parent\n    */\n    modelPrototype[`new${capitalize(key)}`] = function(attrs) {\n      let parent = association.schema[toCollectionName(association.modelName)].new(attrs);\n\n      this[key] = parent;\n\n      return parent;\n    };\n\n    /*\n      object.createParent\n        - creates a new saved associated parent, and immediately persists both models\n    */\n    modelPrototype[`create${capitalize(key)}`] = function(attrs) {\n      let parent = association.schema[toCollectionName(association.modelName)].create(attrs);\n\n      this[key] = parent;\n      this.save();\n\n      return parent;\n    };\n  }\n\n  /**\n   *\n   *\n   * @public\n  */\n  disassociateAllDependentsFromTarget(model) {\n    let owner = this.ownerModelName;\n    let dependents = this.schema[toCollectionName(owner)]\n      .where({ [this.getForeignKey()]: model.id });\n\n    dependents.models.forEach(dependent => {\n      dependent.disassociate(model, this);\n      dependent.save();\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/orm/associations/has-many.js":"import Association from './association';\nimport Collection from '../collection';\nimport _assign from 'lodash/assign';\nimport _compact from 'lodash/compact';\nimport { capitalize, camelize, singularize } from 'ember-cli-mirage/utils/inflector';\nimport { toCollectionName } from 'ember-cli-mirage/utils/normalize-name';\nimport assert from 'ember-cli-mirage/assert';\n\n/**\n * @class HasMany\n * @extends Association\n * @constructor\n * @public\n */\nexport default class HasMany extends Association {\n\n  /**\n   * @method getForeignKeyArray\n   * @return {Array} Array of camelized model name of associated objects\n   * and foreign key for the object owning the association\n   * @public\n   */\n  getForeignKeyArray() {\n    return [camelize(this.ownerModelName), this.getForeignKey()];\n  }\n\n  /**\n   * @method getForeignKey\n   * @return {String} Foreign key for the object owning the association\n   * @public\n   */\n  getForeignKey() {\n    return `${singularize(camelize(this.key))}Ids`;\n  }\n\n  /**\n   * Registers has-many association defined by given key on given model,\n   * defines getters / setters for associated records and associated records' ids,\n   * adds methods for creating unsaved child records and creating saved ones\n   *\n   * @method addMethodsToModelClass\n   * @param {Function} ModelClass\n   * @param {String} key\n   * @public\n   */\n  addMethodsToModelClass(ModelClass, key) {\n    let modelPrototype = ModelClass.prototype;\n    let association = this;\n    let foreignKey = this.getForeignKey();\n    let associationHash = { [key]: this };\n\n    modelPrototype.hasManyAssociations = _assign(modelPrototype.hasManyAssociations, associationHash);\n\n    // Add to target's dependent associations array\n    this.schema.addDependentAssociation(this, this.modelName);\n\n    // TODO: look how this is used. Are these necessary, seems like they could be gotten from the above?\n    // Or we could use a single data structure to store this information?\n    modelPrototype.associationKeys.push(key);\n    modelPrototype.associationIdKeys.push(foreignKey);\n\n    Object.defineProperty(modelPrototype, foreignKey, {\n\n      /*\n        object.childrenIds\n          - returns an array of the associated children's ids\n      */\n      get() {\n        this._tempAssociations = this._tempAssociations || {};\n        let tempChildren = this._tempAssociations[key];\n        let ids = [];\n\n        if (tempChildren) {\n          ids = tempChildren.models.map(model => model.id);\n        } else {\n          ids = this.attrs[foreignKey] || [];\n        }\n\n        return ids;\n      },\n\n      /*\n        object.childrenIds = ([childrenIds...])\n          - sets the associated children (via id)\n      */\n      set(ids) {\n        let tempChildren;\n\n        if (ids === null) {\n          tempChildren = [];\n        } else if (ids !== undefined) {\n          assert(Array.isArray(ids), `You must pass an array in when seting ${foreignKey} on ${this}`);\n          tempChildren = association.schema[toCollectionName(association.modelName)].find(ids);\n        }\n\n        this[key] = tempChildren;\n      }\n    });\n\n    Object.defineProperty(modelPrototype, key, {\n\n      /*\n        object.children\n          - returns an array of associated children\n      */\n      get() {\n        this._tempAssociations = this._tempAssociations || {};\n        let collection = null;\n\n        if (this._tempAssociations[key]) {\n          collection = this._tempAssociations[key];\n        } else {\n          if (this[foreignKey]) {\n            collection = association.schema[toCollectionName(association.modelName)].find(this[foreignKey]);\n          } else {\n            collection = new Collection(association.modelName);\n          }\n\n          this._tempAssociations[key] = collection;\n        }\n\n        return collection;\n      },\n\n      /*\n        object.children = [model1, model2, ...]\n          - sets the associated children (via array of models or Collection)\n      */\n      set(models) {\n        if (models instanceof Collection) {\n          models = models.models;\n        }\n\n        models = models ? _compact(models) : [];\n        this._tempAssociations = this._tempAssociations || {};\n\n        this._tempAssociations[key] = new Collection(association.modelName, models);\n\n        if (association.inverse())  {\n          models.forEach(model => {\n            model.associate(this, association.inverse());\n          });\n        }\n      }\n    });\n\n    /*\n      object.newChild\n        - creates a new unsaved associated child\n    */\n    modelPrototype[`new${capitalize(camelize(singularize(association.key)))}`] = function(attrs = {}) {\n      let child = association.schema[toCollectionName(association.modelName)].new(attrs);\n\n      let children = this[key].models;\n      children.push(child);\n      this[key] = children;\n\n      return child;\n    };\n\n    /*\n      object.createChild\n        - creates a new saved associated child, and immediately persists both models\n    */\n    modelPrototype[`create${capitalize(camelize(singularize(association.key)))}`] = function(attrs = {}) {\n      let child = association.schema[toCollectionName(association.modelName)].create(attrs);\n\n      // this[key].add(child);\n      let children = this[key].models;\n      children.push(child);\n      this[key] = children;\n\n      this.save();\n\n      return child.reload();\n    };\n  }\n\n  /**\n   *\n   *\n   * @public\n  */\n  disassociateAllDependentsFromTarget(model) {\n    let owner = this.ownerModelName;\n    let dependents = this.schema[toCollectionName(owner)]\n      .where((potentialOwner) => {\n        let currentIds = potentialOwner[this.getForeignKey()];\n\n        // Need this check because currentIds could be null\n        return currentIds && currentIds.includes(model.id);\n      });\n\n    dependents.models.forEach(dependent => {\n      dependent.disassociate(model, this);\n      dependent.save();\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/shorthands/base.js":"import { toCollectionName } from 'ember-cli-mirage/utils/normalize-name';\nimport BaseRouteHandler from '../base';\n\nexport default class BaseShorthandRouteHandler extends BaseRouteHandler {\n\n  constructor(schema, serializerOrRegistry, shorthand, path, options = {}) {\n    super();\n    shorthand = shorthand || this.getModelClassFromPath(path);\n    this.schema = schema;\n    this.serializerOrRegistry = serializerOrRegistry;\n    this.shorthand = shorthand;\n    this.options = options;\n\n    let type = Array.isArray(shorthand) ? 'array' : typeof shorthand;\n    if (type === 'string') {\n      let modelClass = this.schema[toCollectionName(shorthand)];\n      this.handle = (request) => {\n        return this.handleStringShorthand(request, modelClass);\n      };\n    } else if (type === 'array') {\n      let modelClasses = shorthand.map((modelName) => this.schema[toCollectionName(modelName)]);\n      this.handle = (request) => {\n        return this.handleArrayShorthand(request, modelClasses);\n      };\n    }\n  }\n\n  // handleStringShorthand() {\n  //\n  // }\n  //\n  // handleArrayShorthand() {\n  //\n  // }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/shorthands/delete.js":"import assert from 'ember-cli-mirage/assert';\nimport BaseShorthandRouteHandler from './base';\nimport { pluralize, camelize } from 'ember-cli-mirage/utils/inflector';\n\nexport default class DeleteShorthandRouteHandler extends BaseShorthandRouteHandler {\n\n  /*\n    Remove the model from the db of type *camelizedModelName*.\n\n    This would remove the user with id :id:\n      Ex: this.del('/contacts/:id', 'user');\n  */\n  handleStringShorthand(request, modelClass) {\n    let modelName = this.shorthand;\n    let camelizedModelName = camelize(modelName);\n    assert(\n      modelClass,\n      `The route handler for ${request.url} is trying to access the ${camelizedModelName} model, but that model doesn't exist. Create it using 'ember g mirage-model ${modelName}'.`\n    );\n\n    let id = this._getIdForRequest(request);\n    return modelClass.find(id).destroy();\n  }\n\n  /*\n    Remove the model and child related models from the db.\n\n    This would remove the contact with id `:id`, as well\n    as this contact's addresses and phone numbers.\n      Ex: this.del('/contacts/:id', ['contact', 'addresses', 'numbers');\n  */\n  handleArrayShorthand(request, modelClasses) {\n    let id = this._getIdForRequest(request);\n\n    let parent = modelClasses[0].find(id);\n    let childTypes = modelClasses.slice(1)\n      .map((modelClass) => pluralize(modelClass.camelizedModelName));\n\n    // Delete related children\n    childTypes.forEach((type) => parent[type].destroy());\n    parent.destroy();\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/shorthands/get.js":"import assert from 'ember-cli-mirage/assert';\nimport BaseShorthandRouteHandler from './base';\nimport { Response } from 'ember-cli-mirage';\nimport { singularize, camelize } from 'ember-cli-mirage/utils/inflector';\n\nexport default class GetShorthandRouteHandler extends BaseShorthandRouteHandler {\n\n  /*\n    Retrieve a model/collection from the db.\n\n    Examples:\n      this.get('/contacts', 'contact');\n      this.get('/contacts/:id', 'contact');\n  */\n  handleStringShorthand(request, modelClass) {\n    let modelName = this.shorthand;\n    let camelizedModelName = camelize(modelName);\n\n    assert(\n      modelClass,\n      `The route handler for ${request.url} is trying to access the ${camelizedModelName} model, but that model doesn't exist. Create it using 'ember g mirage-model ${modelName}'.`\n    );\n\n    let id = this._getIdForRequest(request);\n    if (id) {\n      let model = modelClass.find(id);\n      if (!model) {\n        return new Response(404);\n      } else {\n        return model;\n      }\n    } else if (this.options.coalesce && request.queryParams && request.queryParams.ids) {\n      return modelClass.find(request.queryParams.ids);\n    } else {\n      return modelClass.all();\n    }\n  }\n\n  /*\n    Retrieve an array of collections from the db.\n\n    Ex: this.get('/home', ['contacts', 'pictures']);\n  */\n  handleArrayShorthand(request, modelClasses) {\n    let keys = this.shorthand;\n    let id = this._getIdForRequest(request);\n\n    /*\n    If the first key is singular and we have an id param in\n    the request, we're dealing with the version of the shorthand\n    that has a parent model and several has-many relationships.\n    We throw an error, because the serializer is the appropriate\n    place for this now.\n    */\n    assert(\n      !id || singularize(keys[0]) !== keys[0],\n      `It looks like you're using the \"Single record with\n      related records\" version of the array shorthand, in addition to opting\n      in to the model layer. This shorthand was made when there was no\n      serializer layer. Now that you're using models, please ensure your\n      relationships are defined, and create a serializer for the parent\n      model, adding the relationships there.`\n    );\n\n    return modelClasses.map((modelClass) => modelClass.all());\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/shorthands/head.js":"import assert from 'ember-cli-mirage/assert';\nimport BaseShorthandRouteHandler from './base';\nimport { Response } from 'ember-cli-mirage';\nimport { camelize } from 'ember-cli-mirage/utils/inflector';\n\nexport default class HeadShorthandRouteHandler extends BaseShorthandRouteHandler {\n\n  /*\n    Retrieve a model/collection from the db.\n\n    Examples:\n      this.head('/contacts', 'contact');\n      this.head('/contacts/:id', 'contact');\n  */\n  handleStringShorthand(request, modelClass) {\n    let modelName = this.shorthand;\n    let camelizedModelName = camelize(modelName);\n\n    assert(\n      modelClass,\n      `The route handler for ${request.url} is trying to access the ${camelizedModelName} model, but that model doesn't exist. Create it using 'ember g mirage-model ${modelName}'.`\n    );\n\n    let id = this._getIdForRequest(request);\n    if (id) {\n      let model = modelClass.find(id);\n      if (!model) {\n        return new Response(404);\n      } else {\n        return new Response(204);\n      }\n    } else if (this.options.coalesce && request.queryParams && request.queryParams.ids) {\n      let model = modelClass.find(request.queryParams.ids);\n\n      if (!model) {\n        return new Response(404);\n      } else {\n        return new Response(204);\n      }\n    } else {\n      return new Response(204);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/shorthands/post.js":"import assert from 'ember-cli-mirage/assert';\nimport BaseShorthandRouteHandler from './base';\nimport { camelize } from 'ember-cli-mirage/utils/inflector';\n\nexport default class PostShorthandRouteHandler extends BaseShorthandRouteHandler {\n\n  /*\n    Push a new model of type *camelizedModelName* to the db.\n\n    For example, this will push a 'user':\n      this.post('/contacts', 'user');\n  */\n\n  handleStringShorthand(request, modelClass) {\n    let modelName = this.shorthand;\n    let camelizedModelName = camelize(modelName);\n    assert(\n      modelClass,\n      `The route handler for ${request.url} is trying to access the ${camelizedModelName} model, but that model doesn't exist. Create it using 'ember g mirage-model ${modelName}'.`\n    );\n\n    let attrs = this._getAttrsForRequest(request, modelClass.camelizedModelName);\n    return modelClass.create(attrs);\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-ember-cli-mirage/node_modules/ember-cli-mirage/addon/route-handlers/shorthands/put.js":"import assert from 'ember-cli-mirage/assert';\nimport BaseShorthandRouteHandler from './base';\nimport { camelize } from 'ember-cli-mirage/utils/inflector';\n\nexport default class PutShorthandRouteHandler extends BaseShorthandRouteHandler {\n\n  /*\n    Update an object from the db, specifying the type.\n\n      this.put('/contacts/:id', 'user');\n  */\n  handleStringShorthand(request, modelClass) {\n    let modelName = this.shorthand;\n    let camelizedModelName = camelize(modelName);\n\n    assert(\n      modelClass,\n      `The route handler for ${request.url} is trying to access the ${camelizedModelName} model, but that model doesn't exist. Create it using 'ember g mirage-model ${modelName}'.`\n    );\n\n    let id = this._getIdForRequest(request);\n    let attrs = this._getAttrsForRequest(request, modelClass.camelizedModelName);\n\n    return modelClass.find(id).update(attrs);\n  }\n\n}\n"}